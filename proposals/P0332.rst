========================================================================
D0332r2 : Relaxed Incomplete Multidimensional Array Type Declaration
========================================================================

:Project: ISO JTC1/SC22/WG21: Programming Language C++
:Number: D0332r2
:Date: 2017-10-091
:Reply-to: hcedwar@sandia.gov, balelbach@lbl.gov
:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Bryce Lelbach 
:Contact: balelbach@lbl.gov
:Author: Christian Trott
:Contact: crtrott@sandia.gov
:Author: Mauro Bianco
:Contact: mbianco@cscs.ch
:Author: Athanasios Iliopoulos
:Contact: athanasios.iliopoulos@nrl.navy.mil
:Author: John Michopoulos
:Contact: john.michopoulos@nrl.navy.mil
:Audience: Library Evolution Working Group (LEWG)
:Audience: Evolution Working Group (LEWG)
:URL: https://github.com/kokkos/array_ref/blob/master/proposals/P0332.rst

+------------+-------------------------------------------------------------+
| **Revision History**                                                     |
+------------+-------------------------------------------------------------+
| N4356      | Original proposal                                           |
+------------+-------------------------------------------------------------+
| P0009r0    | Original multidimensional array reference paper with        |
|            | motivation, specification, and examples.                    |
+------------+-------------------------------------------------------------+
| P0009r1    | Revised with renaming from ``view`` to ``array_ref``        |
|            | and allow unbounded rank through variadic arguments.        |
+------------+-------------------------------------------------------------+
| P0332r0    | Relaxed array declaration moved from P0009.                 |
+------------+-------------------------------------------------------------+
| P0332r1    | Align with updates to P0009.                                |
|            | Add examples of precedents.                                 |
|            | P0009 moved by LEWG to LWG                                  |
|            | Reviewed by EWG in 2017 Albuquerque                         |
+------------+-------------------------------------------------------------+
| P0332r2    | Fully address scope of EWG feedback on N4356                |
+------------+-------------------------------------------------------------+
| **References**                                                           |
+------------+-------------------------------------------------------------+
| P0009      | Multidimensional array reference specification              |
+------------+-------------------------------------------------------------+
| P0331      | Multidimensional array reference motivation and examples    |
+------------+-------------------------------------------------------------+



******************************************************************
Motivation
******************************************************************

The dimensions of multidimensional array reference ``mdspan``
(P0009) are declared a syntactically verbose property argument.
We propose a trivial, non-breaking relaxation of the
array type declaration in **11.3.4p3** to allow a concise
and intuitive syntax for multidimensional declarations.

.. code-block:: c++

  template< typename DataType , typename Properties... >
  struct mdspan ;

  // Three dimensional tensor type declaration with
  // verbose syntax and left-to-right increasing stride.

  using tensor = std::mdspan<double,std::extents<std::dynamic_extent,std::dynamic_extent,std::dynamic_extent>,LayoutLeft> ;

  // Three dimensional tensor type declaration with concise syntax
  // and left-to-right increasing stride.

  using tensor = mdspan<double[][][],LayoutLeft> ;

..

The motivating ``mdspan`` library moved by LEWG to LWG in 2017-Albuquerque.

----------------------------------------------------------------------
Why Not
----------------------------------------------------------------------

``mdspan<double,std::dynamic_extent,std::dynamic_extent,std::dynamic_extent,LayoutLeft>``

  - Does not allow LayoutLeft or other properties to be a type.
  - Still requires ``dynamic_extent`` magic number

******************************************************************************
Proposal
******************************************************************************

The current array type declarator constraints are
defined in in **11.3.4.p3** as follows.

  When several “array of” specifications are adjacent,
  a multidimensional array type is created;
  only the first of the constant expressions
  that specify the bounds of the arrays may be omitted.
  In addition to declarations in which an
  incomplete object type is allowed,
  an array bound may be omitted in some cases
  in the declaration of a function parameter (11.3.5).
  An array bound may also be omitted when the declarator
  is followed by an initializer (11.6)
  or when a declarator for a static data member
  is followed by a brace-or-equal-initializer (12.2).
  In both cases the bound is calculated from the
  number of initial elements (say, N) supplied (11.6.1),
  and the type of the identifier of D is “array of N T”.
  Furthermore, if there is a preceding declaration
  of the entity in the same scope in which the bound was specified,
  an omitted array bound is taken to be the same as in that
  earlier declaration, and similarly for the definition of
  a static data member of a class.

For ``mdspan`` to have a concise and intuitive syntax
the array type declarator constraints must be relaxed.
The following wording change is proposed.

  When several “array of” specifications are adjacent,
  a multidimensional array type is created.
  In declarations in which an incomplete object type is allowed
  any of the constant expressions that
  specify the bounds of the arrays may be omitted.
  The first of the constant expressions
  that specify the bounds of the arrays may be omitted

    - in some cases in the declaration of a function parameter (11.3.5),
    - when the declarator is followed by an initializer (11.6),
    - when a declarator for a static data member
      is followed by a brace-or-equal-initializer (12.2), or
    - if there is a preceding declaration
      of the entity in the same scope in which the bound was specified.

  In the initializer cases the bound is calculated from the
  number of initial elements (say, N) supplied (11.6.1),
  and the type of the identifier of D is “array of N T”.
  In the preceding declaration case
  an omitted array bound is taken to be the same as in that
  earlier declaration, and similarly for the definition of
  a static data member of a class.


******************************************************************************
Precedence and Feasibility
******************************************************************************

An incomplete array type ``T[]`` to concisely indicate
an array of runtime length is used by
``std::unique_ptr<T[]>`` (23.11.1.3),
``std::shared_ptr<T>`` where ``T`` is ``U[]`` (23.11.2.2),
and P0674 ``make_shared<T[][N1][N2]>``.


This minor language specification change has been implemented with
a trivial (one line) patch to Clang and was permissible in gcc prior to
version 5.


******************************************************************************
Holistic View
******************************************************************************

From 2015-Lenexa notes on N4356:
*Stepping back for a second, I think this is a small change
but there are a whole bunch of ways of constructing types and
we disallow many because they would give uninhabited types.
But then look at std::result_of, after this change you can use
std::result_of on a whole bunch of types,
but not on a function type (ironically).
I think there may be some sense in this,
I'd like to see some more holistic view of this,
I don't want to see pointers or references to these,
or functions declared with these things as arguments.*


Let ``S`` be an incomplete multdimensional array type
greater than rank 1 rom which an extent other than the
leading extent is ommitted.

**6.9 Types, p5**

  *A class that has been declared but not defined, an enumeration type
  in certain contexts (10.2), or an array of unknown bound or of
  incomplete element type, is an incompletely-defined object type.
  Incompletely-defined object types and cv void are incomplete types (6.9.1).
  Objects shall not be defined to have an incomplete type.*

``S`` can never be used to declare an object.

**6.9 Types, p6**

  *The declared type of an array object might be an array of
  unknown bound and therefore be incomplete at one point in a
  translation unit and complete later on; the array types at
  those two points (“array of unknown bound of T” and “array of N T”)
  are different types. The type of a pointer to array of unknown bound,
  or of a type defined by a typedef declaration to be an array of
  unknown bound, cannot be completed.*

The type of a pointer to ``S`` is an incomplete type,
and therefore can never be used to declare an object.

**7.2 Array-to-pointer conversion**

  *An lvalue or rvalue of type “array of N T” or
  “array of unknown bound of T” can be converted to a prvalue of
  type “pointer to T”. The temporary materialization conversion (7.4)
  is applied. The result is a pointer to the first element of the array.*

**7.4 Temporary materialization conversion [conv.rval]**

  *A prvalue of type T can be converted to an xvalue of type T.
  This conversion initializes a temporary object (15.2) of type T
  from the prvalue by evaluating the prvalue with the
  temporary object as its result object, and produces an xvalue
  denoting the temporary object. T shall be a complete type.*

The decay of ``int[][M][]`` is ``int(*)[M][])`` which is an incomplete type 
and objects cannot be declared for an incomplete type.
Therefore converting ``int[][M][]`` to a pointer is an error.

**11.3.5 Functions, p5**

  *After determining the type of each parameter,
  any parameter of type “array of T” or of function type T
  is adjusted to be “pointer to T”.*


*10.1.1p7*

  *The name of a declared but undefined class can be used
  in an extern declaration. Such a declaration can
  only be used in ways that do not require a complete class type.*

Incomplete array types cannot be used as the return type
of a function.

------------------------------------------------------------------------------
type_traits interaction
------------------------------------------------------------------------------

.. code-block:: c++

  using S = double[10][20][] ;
  rank_v<S> == 3``
  extent_v<S,0> == 10``
  extent_v<S,1> == 20``
  extent_v<S,2> == 0``

  remove_extent_t<S> // is an incomplete type
  is_same_v< remove_extent_t<S> , double[20][] >

  remove_extent_t< remove_extent_t<S> > // is an incomplete type
  is_same_v< remove_extent_t< remove_extent_t<S> > , double[] >

  decay_t<S> // is an incomplete type
  is_same_v< decay_t<S> , double(*)[20][] >

..
 

------------------------------------------------------------------------------
Type Deduction Non-Issue
------------------------------------------------------------------------------

.. code-block:: c++

  template <typename T>
  void f( span<T[3][5]> ); // A

  template <typename T>
  void f( span<T[1][3][5]> ); // B

  template <typename T>
  void f( span<T[1][][5]> ); // C

  template <typename T, std::size_t M, std::size_t N>
  void f( span<T[N][M][]> ) // D

  template <typename T, std::size_t M, std::size_t N>
  void f( span<T[][N][M]> ); // E

  template <typename T>
  void f( T[][3][5] ); // F
    // adjusted to pointer T(*)[3][5]

  template <typename T>
  void f( T[][][5] ); // G
    // adjusted to pointer T(*)[][5]
    // invalid due to T[][5] incomplete array type

  template <typename T, std::size_t M >
  void f( T[][M][] ) // H
    // adjusted to pointer T(*)[M][]
    // invalid due to T[][5] incomplete array type

  template <typename T, std::size_t M, std::size_t N>
  void f( T[][N][M] ); // I
    // adjusted to pointer T(*)[M][N]


  int foo( span<int[1][3][5]> x )
  {
    f(x); // no ambiquity
    // COULD match A with T == int[1]
    // DOES  match B with T == int ; more specialized
    // NOT match D because [3] != []
    // NOT match E because [5] != []
    // NOT match F because [1] != []
  }

  int foo( int y[][3][5] )
  {
    f(y);
    // DOES match F ; more specialized
    // COULD match I 
  }

..







