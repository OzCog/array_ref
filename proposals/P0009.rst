===================================================================
D0009r3 : Polymorphic Multidimensional Array Reference
===================================================================

:Project: ISO JTC1/SC22/WG21: Programming Language C++
:Number: D0009r3
:Date: 2016-06-23
:Reply-to: hcedwar@sandia.gov, balelbach@lbl.gov
:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Bryce Lelbach 
:Contact: balelbach@lbl.gov
:Author: Christian Trott
:Contact: crtrott@sandia.gov
:Author: Mauro Bianco
:Contact: mbianco@cscs.ch
:Author: Robin Maffeo
:Contact: Robin.Maffeo@amd.com
:Author: Ben Sander
:Contact: ben.sander@amd.com
:Audience: Library Evolution Working Group (LEWG)
:Audience: Evolution Working Group (EWG) for concise array declaration
:URL: https://github.com/kokkos/array_ref/blob/master/proposals/P0009.rst



+------------+-------------------------------------------------------------+
| **Revision History**                                                     |
+------------+-------------------------------------------------------------+
| P0009r0    | Original multidimensional array reference paper with        |
|            | motivation, specification, and examples.                    |
+------------+-------------------------------------------------------------+
| P0009r1    | Revised with renaming from ``view`` to ``array_ref``        |
|            | and allow unbounded rank through variadic arguments.        |
+------------+-------------------------------------------------------------+
| P0009r2    | Adding details for layout mapping.                          |
| *(current)*| Move motivation, examples, and relaxed array declaration    |
|            | to separate papers.                                         |
+------------+-------------------------------------------------------------+
| **References**                                                           |
+------------+-------------------------------------------------------------+
| P0331      | Multidimensional array reference motivation and examples    |
+------------+-------------------------------------------------------------+
| P0332      | Relaxed incomplete array type declaration                   |
+------------+-------------------------------------------------------------+
| P0122      | span: bounds-safe views for sequences of objects            |
+------------+-------------------------------------------------------------+
| P0367      | Accessors                                                   |
+------------+-------------------------------------------------------------+
| earlier related papers: N4512, N4355, N4300, N4222                       |
+------------+-------------------------------------------------------------+

.. sectnum::


******************************************************************
Description
******************************************************************

The header ``<array_ref>`` defines types and functions for
mapping indices from a multidimensional index space (the domain)
to members of a contiguous span of objects (the codomain).
This **layout mapping** is one *property* of the
``array_ref`` that may be specified through a template parameter.
The intent is that *properties** are an extensible set of options
for multi-index mapping and member access.
For example,
bounds checking the input multi-index versus the multdimensional extents or
accessing members through an atomic interface.
The recent Accessors paper (P0367) introduces a rich set of potential access properties.

----------------------------------------------------------------------------
Unresolved class name
----------------------------------------------------------------------------

The current ``array_ref`` name for the proposed functionality is
not entirely satisfactory to the authors; however, a more appropriate
name has yet to be identified.
The ``accessor`` name in P0367 is a possibility in that it denotes a polymorphic
mechanism for accessing an object or span of objects.

----------------------------------------------------------------------------
Unresolved domain index space specification
----------------------------------------------------------------------------

Two possible mechanisms for specifying the domain multi-index space are described.
The preferred mechanism (A) is concise and aligns with native syntax
for specifying multidimensional array extents.
However, the preferred mechanism requires a trivial language change to relax
the specification for *incomplete* array types (P0332).
The less desirable mechanism (B) requires an additional ``extents``
property and associated *dynamic extent* magic value.


******************************************************************
Proposal
******************************************************************

----------------------------------------------------------------------------
Header ``<array_ref>`` synopsis
----------------------------------------------------------------------------

.. code-block:: c++

  // For exposition only:
  namespace std {
  namespace experimental {
  namespace detail {
    template< typename ArrayRef , typename ... SliceSpecifiers >
    class subarray_deduction ;
  }}}

  namespace std {
  namespace experimental {

    template< typename DataType , typename ... Properties >
    class array_ref ;

    // return type of subarray is an array_ref
    template< typename DataType , typename ... Properties , typename ... SliceSpecifiers >
    typename detail::subarray_deduction< array_ref< DataType , Properties... > , SliceSpecifiers ... >::type /* exposition only */
    subarray( array_ref< DataType, Properties ... > const & , SliceSpecifiers ... ) noexcept;

  }}

..

The ``array_ref`` class maps a multi-index within a multi-index space (the domain) to
a reference to an object within a span of objects (the codomain).

The ``subarray`` free function generates an ``array_ref`` with a domain contained
within the input ``array_ref`` domain and codomain contained within the input
``array_ref`` codomain.

The ``detail::subarray_deduction`` class is not required and only appears for exposition.
An implementation template class of this form is necessary to deduce the specific
``array_ref`` return type of the ``subarray`` function.


.. code-block:: c++

  namespace std {
  namespace experimental {

    // predefined layout mapping property
    struct layout_right ;
    struct layout_left ;
    struct layout_stride ;

    template <typename T> struct is_layout ;
    template <typename T> constexpr bool is_layout_v = is_layout<T>::value;

    // bounds checking property
    template< bool Enable >
    struct bounds_check_if ;

    using bounds_check = bounds_check_if< true > ;

    template< typename >
    struct is_array_property /* = std::integral_constant<bool,?> */ ;

    template< typename T >
    using is_array_property_v = is_array_property<T>::value ;

    // subarray support
    struct all_type {};
    constexpr all_type all = all_type{};

  }}

..

Three pre-defined layout mappings are as follows.
The ``layout_right`` property denotes the C/C++ standard multidimensional array index mapping 
where the right-most extent is stride one and strides increase right-to-left
as the product of extents.
The ``layout_left`` property denotes the FORTRAN standard multidimensional array index mapping 
where the left-most extent is stride one and strides increase left-to-right
as the product of extents.
The ``layout_stride`` property denotes a multidimensional array index mapping with
arbitrary regular strides for each extent.


.. code-block:: c++

  namespace std {
  namespace experimental {

    template< size_t ... IntegralExtent >
    struct extents ;

    constexpr size_t dyn = /* implementation defined */ ;

  }}

..

The ``extents`` struct and ``dyn`` value are only required for the
less desirable extents specification mechanism B.

----------------------------------------------------------------------------
class template ``array_ref``
----------------------------------------------------------------------------

.. code-block:: c++

  namespace std {
  namespace experimental {
  
  template <typename DataType, typename... Properties>
  class array_ref {
  public:
    // domain and codomain types
  
    using value_type = typename remove_all_extents<DataType>::type ;
    using pointer    = value_type * ;
    using reference  = /* deduced from value_type and Properties... */ ;
    using size_type  = /* deduced from Properties... */ ;
    using layout     = /* deduced from Properties... */ ;

    // iteration types

    using iterator               = /* deduced from DataType */ ;
    using const_iterator         = /* deduced from DataType */ ;
    using reverse_iterator       = reverse_iterator<iterator> ;
    using const_reverse_iterator = reverse_iterator<const_iterator> ;
 
    // constructors, copy, assignment, and destructor
  
    constexpr array_ref() noexcept;
    constexpr array_ref(array_ref&&) noexcept ;
    constexpr array_ref(array_ref const&) noexcept ;
    array_ref& operator=(array_ref&&) noexcept ;
    array_ref& operator=(array_ref const&) noexcept ;
  
    template <typename... IntegralExtent>
    explicit constexpr array_ref(pointer, IntegralExtent... ) noexcept;

    explicit constexpr array_ref(pointer, layout const&) noexcept;

    template <typename UType, typename ... UProperties>
    constexpr array_ref( array_ref<UType, UProperties...> const& ) noexcept;

    template <typename UType, typename ... UProperties>
    array_ref& operator=( array_ref<UType, UProperties...> const& ) noexcept;

    ~array_ref() noexcept ;
  
    // observers of domain: [0..extent(0)) X [0..extent(1)) X ... X [0..extent(rank()-1))
  
    static constexpr int rank() noexcept;
    static constexpr int rank_dynamic() noexcept;
  
    constexpr size_type size() const noexcept;
  
    constexpr size_type extent(int) const noexcept;

    constexpr size_type static_extent(int) noexcept;

    // observers of the codomain: [ data() .. data() + span() )

    constexpr pointer data() const noexcept;
  
    constexpr size_type span() const noexcept;
  
    template <typename... IntegralExtent>
    static constexpr size_type required_span( IntegralExtent ... ) noexcept;
  
    static constexpr size_type required_span( layout const & ) noexcept;

    // observers of the mapping from domain to codomain

    static constexpr bool is_always_unique     = /* deduced */ ;
    static constexpr bool is_always_contiguous = /* deduced */ ;
    static constexpr bool is_always_regular    = /* deduced */ ;

    constexpr bool is_unique() const noexcept;
    constexpr bool is_contiguous() const noexcept;
    constexpr bool is_regular() noexcept;
  
    constexpr size_type stride(int) const noexcept;
  
    // mapping domain index to access codomain element
  
    template <typename... IntegralIndex>
    reference operator()(IntegralIndex...) const noexcept;
  
    template <typename IntegralIndex>
    reference operator[]( IntegralIndex ) const noexcept; // requires rank() == 1

    // iterator support

    constexpr iterator begin() const noexcept ;
    constexpr iterator end()   const noexcept ;
    constexpr const_iterator cbegin() const noexcept ;
    constexpr const_iterator cend()   const noexcept ;
    constexpr reverse_iterator rbegin() const noexcept ;
    constexpr reverse_iterator rend()   const noexcept ;
    constexpr const_reverse_iterator crbegin() const noexcept ;
    constexpr const_reverse_iterator crend()   const noexcept ;
  };

  }}
  
..


Template arguments for preferred mechanism (A)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``template <typename DataType, typename... Properties> class array_ref``

``DataType``

  ``DataType`` declares a complete or incomplete array type (8.3.4.p3).
  Each omitted static extent in the incomplete array type, ``[]``,
  denotes a *dynamic* extent.

  Effects:  The value type, domain index space rank, static extents, and identification of
  dynamic extents is determined from the ``extents`` member of the property pack.

``Properties...``

  The ``Properties...`` argument is a pack of array properties. 

  Requires: ``is_array_property_v< Properties >`` for each member of the pack.

  Effects: The domain to codomain mapping is determined by the property pack.


Template arguments for less desired mechanism (B)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``template <typename DataType, typename... Properties> class array_ref``

``DataType``

  ``DataType`` denotes the value type of the array.


``Properties...``

  The ``Properties...`` argument is a pack of array properties. 

  Requires: ``is_array_property_v< Properties >`` for each member of the pack.

  Effects:  The domain index space rank, static extents, and identification of
  dynamic extents is determined from the ``extents`` member of the property pack.
  The domain to codomain mapping is determined by the remaining members of the property pack


Domain and codomain types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

| ``using value_type = typename remove_all_extents<DataType::type ;``
| ``using pointer = value_type * ;``

  Type of the objects referenced by the array.

``using reference = /* deduced from DataType and Properties... */ ;``

  Reference type for member access.
  For ordinary member access properties this will be ``value_type &``.
  For extra-ordinary member access properties this may be a proxy type.

``using size_type = /* implementation defined */ ;``

  Return type for extents and storage type for dynamic extents.

``using layout = /* deduced from Properties... */ ;``

  Identification of the layout mapping.
  If ``Properties...`` does not include a layout property then
  ``layout`` is ``layout_right`` denoting the traditional C/C++ mapping.


The Domain
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The domain is the Cartesian product of the extents,
``[0..extent(0)) X [0..extent(1)) X ... X [0..extent(rank()-1))``.


``static constexpr int rank() noexcept``

  Returns: rank of the domain.

``static constexpr int rank_dynamic() noexcept``

  Returns: number of extents that are dynamic.

``static constexpr size_type static_extent(int r) const noexcept``

  Requires: ``0 <= r``

  Returns: If ``0 <= r < rank()`` static extent or 0 if a dynamic extent of rank ``r``,
  otherwise 1.

``constexpr size_type extent(int) const noexcept``

  Requires: ``0 <= r``

  Returns: If ``0 <= r < rank()`` extent of rank ``r``, otherwise 1.

``constexpr size_type size() const noexcept``

  Returns: product of extents.


The Codomain
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The codomain is ``[data()..data()+span())``.
Note that not all members of the codomain are accessible through the layout mapping.


| ``constexpr pointer data() const noexcept ;``
| ``constexpr size_type span() const noexcept ;``

  Returns: codomain is ``[ data() .. data() + span() )``

| ``template< typename ... IntegralExtent >``
| ``static constexpr size_type required_span( IntegralExtent ... dynamic_extent ) noexcept``
| ``static constexpr size_type required_span( layout const & ) noexcept``

  Requires: ``conjunction<is_integral<IntegralExtent>::type...>::value``.
  Each ``dynamic_extent`` is non-negative.

  Returns: Required length of contiguous span of objects
  input the *wrapping constructor* with the corresponding extent argument.


The Layout Mapping
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

| ``static constexpr bool is_always_unique =``
| ``constexpr bool is_unique() const noexcept ;``

  A layout mapping is *unique* if each multi-index in the domain
  is mapped to a unique member in the codomain.

| ``static constexpr bool is_always_contiguous =``
| ``constexpr bool is_contiguous() const noexcept ;``

  A layout mapping is *contiguous* if the layout mapping
  can access every member of the codomain.

  A layout mapping that is unique and contiguous is *bijective*
  and has ``size() == span()``.

| ``static constexpr bool is_always_regular =``
| ``constexpr bool:is_regular() const noexcept ;``

  A *regular* layout mapping has constant striding
  between multi-index coordinates.
  Let ``A`` be an ``array_ref`` and ``indices_V...`` and ``indices_U...`` be multi-indices
  in the domain space such that all coordinates are equal except for 
  the *ith* coordinate where ``indices_V[ith] = indices_U[ith] + 1``.
  Then ``stride(ith) = distance(& A(indices_V...) - & A( indices_U... )``
  is constant for all coordinates.

| ``template< typename IntegralType >``
| ``constexpr size_type stride( IntegralType index ) const noexcept``

  Requires: ``is_regular()``.

  Returns: When ``r < rank()`` the distance between members
  when the index of coordinate ``r`` is incremented by one, otherwise 0.


Accessing members in the codomain
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

| ``template< typename ... IntegralIndex >``
| ``reference operator()( IntegralIndex ... indices ) const noexcept``

  Requires: ``conjunction<is_integral<IntegralArgs>::type...>::value``.
  ``rank() <= sizeof...(IntegralArgs)``.
  The ith coordinate of ``indices...``, denoted as ``indices[ith]``,
  is valid: ``0 <= indices[ith] < extent(ith)``.

  Returns: A ``reference`` to the member object mapped to by ``indices...``.

  Remark: An implementation may have rank-specific overloads to better
  enable optimization of the member access operator.
  Since ``extent(ith) == 1`` for ``rank() <= ith`` then extra zero-value
  indices are valid.
  

| ``template< typename IntegralIndex >``
| ``reference operator[]( IntegralIndex index ) const noexcept``

  Requires: ``is_integral<IntegralIndex>::value``.
  ``rank() == 1``.
  ``0 <= i < extent(0)``.

  Returns: A reference to the member object referenced by ``index``.

  Requires: ``0 <= index < extent(0)``


Constructors, copy, assignment, destructor
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``constexpr array_ref() noexcept``

  Effect: Construct a *null* ``array_ref`` with ``data() == nullptr``
  and ``extent(i) == 0`` for all dynamic dimensions.

``constexpr array_ref( const array_ref & rhs ) noexcept``

  Effect: Construct an ``array_ref`` of the same span of objects
  referenced by ``rhs``.

  Remark: There may be other ``Properties...`` dependent effects.

``constexpr array_ref( array_ref && rhs ) noexcept``

  Effect: Construct an ``array_ref`` the span of objects
  referenced by ``rhs`` and then ``rhs`` is a *null* ``array_ref``.

  Remark: There may be other ``Properties...`` dependent effects.

| ``array_ref & operator = ( array_ref const & ) noexcept``
| ``array_ref & operator = ( array_ref && rhs ) noexcept = default``

  Effect: *this has equal domain, equal codomain, and
  equivalent mapping.

  Remark: There may be other ``Properties...`` dependent effects.

| ``template< typename UType , typename ... UProperties >``
| ``constexpr array_ref( array_ref< UType , UProperties ... > const & ) noexcept``
| ``template< typename UType , typename ... UProperties >``
| ``array_ref & operator = ( array_ref< UType , UProperties ... > const & ) noexcept``

  Requires:
  Given ``using V = array_ref<DataType,Properties...>`` and
  ``using U = array_ref<UType,UProperties...>`` then requires
  | ``is_assignable<V::value_type,U::value_type>`` ,
  | ``V::rank() == U::rank()`` ,
  | ``V::static_extent(r) == V::static_extent(r)`` or ``V::static_extent(r) == 0`` for ``0 <= r < V::rank()`` ,
  | compatibility of layout mapping, and
  | potentially other property compatibility conditions.

  Effect: *this has equal domain, equal codomain, and
  equivalent mapping.

  Remark: There may be other ``Properties...`` dependent effects.

| ``template< typename ... IntegralExtent >``
| ``constexpr array_ref( pointer ptr , IntegralExtent ... dynamic_extent) noexcept``

  Requires: ``conjunction<is_integral<IntegralExtent>::type...>::value``.
  ``sizeof...(IntegralExtent) == rank()``.
  Each ``dynamic_extent`` is non-negative.
  The span of objects denoted by ``[ ptr , ptr + required_span(dynamic_extent...) )``,
  shall be a valid contiguous span of objects.

  Effects: The *wrapping constructor* constructs ``* this``
  with domain's dynamic extents equal to the input ``dynamic_extent...``
  and codomain equal to ``[ ptr .. ptr + required_span(dynamic_extent...) )``


``constexpr array_ref( pointer ptr , layout const& lay ) noexcept``

  Requires:
  The span of objects denoted by ``[ ptr , ptr + required_span(lay) )``,
  shall be a valid contiguous span of objects.

  Effects: The *wrapping constructor* constructs ``* this``
  with domain's dynamic extents extracted from ``lay``
  and codomain equal to ``[ ptr .. ptr + required_span(dynamic_extent...) )``

``~array_ref()``

  Effect: Assigns ``this`` to be a *null* ``array_ref``.

  Remark: There may be other ``Properties...`` dependent effects.


Iterator types and member functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Iteration occurs over members of the codomain that are accessible
through the layout mapping.
Order of iteration is not specified.
Tractability and performance of the iterator is necessarily dependent upon the
complexity of the layout mapping.

An ``is_always_contiguous`` layout mapping can be expected to have a performant iteration mechanism;
e.g., the iterator could be a pointer.

A non- ``is_always_contiguous`` that ``is_always_unique`` and ``is_always_regular``
layout mapping may have a *tractable* iteration mechanism
that iterates the domain space and maps each index to a member.
Note that such an iterator is necessarily *heavy weight* as it must include the
bounds of the domain's extents.

A non-contiguous and non-unique or irregular layout mapping may be prohibitively
non-performant due to necessarily generating an array of references to
members of the codomain and then iterating that array.

| ``using iterator = /* deduced from DataType and Properties */ ;``
| ``using const_iterator = /* deduced from DataType and Properties */ ;``
| ``constexpr iterator begin() const noexecept``
| ``constexpr iterator end() const noexecept``
| ``constexpr const_iterator cbegin() const noexecept``
| ``constexpr const_iterator cend() const noexecept``
| ``constexpr reverse_iterator rbegin() const noexecept``
| ``constexpr reverse_iterator rend() const noexecept``
| ``constexpr reverse_const_iterator crbegin() const noexecept``
| ``constexpr reverse_const_iterator crend() const noexecept``

  Remark: The order of iteration is unspecified and layout dependent.
  If the layout mapping **is** unique then iterating the span
  is equivalent to iterating all indices of the domain
  multidimensional index space.


----------------------------------------------------------------------------
``subarray``
----------------------------------------------------------------------------

| ``template< typename DataType , typename ... Properties , typename ... SliceSpecifiers >``
| ``typename detail::subarray_deduction< array_ref< DataType , Properties... > , SliceSpecifiers ... >::type /* exposition only */``
| ``subarray( array_ref< DataType, Properties ... > const & U , SliceSpecifiers ... S ) noexcept;``


  Requires: ``U.rank() == sizeof...(SliceSpecifiers)``.
  The *ith* member of the ``S`` denoted ``S[ith]``
  is an integral *value* or an integral *range* denoted by
  one of the following.

  - an ``initializer_list<T>`` of integral type ``T`` and size 2
  - a ``pair<T,T>`` of integral type ``T`` 
  - a ``tuple<T,T>``  of integral type ``T``
  - an ``array<T,2>`` of integral type ``T``
  - ``all`` to denote ``[0..extent(ith))``
  
  ``0 <= begin(S[ith]) <= end(S[ith]) <= A.extent(ith)``
  
  Returns:  An ``array_ref V`` with a domain contained within the domain of ``U`` ,
  codomain contained within the codomain of ``U`` ,
  ``V.rank()`` is the number of integral ranges in ``SlicedSpecifiers`` ,
  ``U( begin(S)... )`` refers to the same codomain member
  refered to by the mapping the zero-index of ``V`` ,
  each integral value in ``S...`` contracts the corresponding
  extent of ``U``.

  Example:
  
.. code-block:: c++

  // A.rank() == 4 and reference is lvalue reference
  void foo( array_ref< DataType , Properties ... > const & A )
  {
    auto B = subarray( A , make_pair(1,A.extent(0)-1) , 1 , make_pair(2,A.extent(2) , 2 );
    assert( & B(0,0) == A(1,1,2,2) );
    assert( & B(1,0) == A(2,1,2,2) );
    assert( & B(0,1) == A(1,1,3,2) );
  }

..

----------------------------------------------------------------------------
Layout Mapping
----------------------------------------------------------------------------

An ``array_ref`` maps multi-indices in the domain to objects in the codomain
by composing a *layout mapping* with a span of objects.
The layout mapping is an extension point such that an ``array_ref`` may be
instantiated with non-standard layout mappings.


Standard Layouts
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The three standard layouts have the following layout mapping traits.

``layout_right``

  | ``is_always_unique == true``
  | ``is_always_contiguous == true``
  | ``is_always_regular == true``
  | When ``0 < rank()`` then ``stride(rank()-1) == 1`` .
  | When ``1 < rank()`` then ``stride(r-1) = stride(r) * extent(r)`` for ``0 < r < rank()`` ..

``layout_left``

  | ``is_always_unique == true``
  | ``is_always_contiguous == true``
  | ``is_always_regular == true``
  | When ``0 < rank()`` then ``stride(0) == 1`` .
  | When ``1 < rank()`` then ``stride(r) = stride(r-1) * extent(r-1)`` for ``0 < r < rank()`` ..

``layout_stride``

  | ``is_always_unique == false``
  | ``is_always_contiguous == false``
  | ``is_always_regular == true``


Concept for Extensible Layout Mapping
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A *layout* class conforms to the following interface such that an
``array_ref`` can compose the layout mapping with its ``array_ref``
codomain member reference generation.

.. code-block:: c++

  class layout_concept /* exposition only */ {
  public:
 
    template< typename ExtentType , ExtentsType ... >
    class mapping {
    public:

      // domain types
  
      using size_type = ExtentType ;

      // constructors, copy, assignment, and destructor
  
      constexpr mapping() noexcept;
      constexpr mapping(mapping&&) noexcept ;
      constexpr mapping(mapping const&) noexcept ;
      mapping& operator=(mapping&&) noexcept ;
      mapping& operator=(mapping const&) noexcept ;
  
      template <typename... IntegralExtent>
      explicit constexpr mapping( IntegralExtent... ) noexcept;

      explicit constexpr mapping( layout_concept const&) noexcept;

      ~mapping() noexcept ;
  
      // observers of domain: [0..extent(0)) X [0..extent(1)) X ... X [0..extent(rank()-1))
  
      static constexpr int rank() noexcept;
      static constexpr int rank_dynamic() noexcept;
  
      constexpr size_type size() const noexcept;
  
      constexpr size_type extent(int) const noexcept;

      constexpr size_type static_extent(int) noexcept;

      // observers of the codomain: [0..span())

      constexpr size_type span() const noexcept;
  
      template <typename... IntegralExtent>
      static constexpr size_type required_span( IntegralExtent ... ) noexcept;
  
      static constexpr size_type required_span( layout_concept const & ) noexcept;

      // observers of the mapping from domain to codomain

      static constexpr bool is_always_unique     = /* deduced */ ;
      static constexpr bool is_always_contiguous = /* deduced */ ;
      static constexpr bool is_always_regular    = /* deduced */ ;

      constexpr bool is_unique() const noexcept;
      constexpr bool is_contiguous() const noexcept;
      constexpr bool is_regular() noexcept;
  
      constexpr size_type stride(int) const noexcept;
  
      // mapping domain index to access codomain element
  
      template <typename... IntegralIndex>
      constexpr size_type operator()(IntegralIndex...) const noexcept;
  
      // iterator support

      using iterator               = /* dereferences to size_type */ ;
      using const_iterator         = /* dereferences to size_type */ ;
      using reverse_iterator       = reverse_iterator<iterator> ;
      using const_reverse_iterator = reverse_iterator<const_iterator> ;

      constexpr iterator begin() const noexcept ;
      constexpr iterator end()   const noexcept ;
      constexpr const_iterator cbegin() const noexcept ;
      constexpr const_iterator cend()   const noexcept ;
      constexpr reverse_iterator rbegin() const noexcept ;
      constexpr reverse_iterator rend()   const noexcept ;
      constexpr const_reverse_iterator crbegin() const noexcept ;
      constexpr const_reverse_iterator crend()   const noexcept ;
    };
  };

..

``template< typename ExtentType , ExtentType ... Extent > class mapping``

  Requires: ``is_integral<ExtentType>`` and ``Extent`` is non-negative.

  Effects: Defines the domain index space where
  ``rank() == sizeof...(Extent)`` and each ``Extent == 0``
  denotes a dynamic dimension.

| ``constexpr mapping() noexcept;``
| ``constexpr mapping(mapping&&) noexcept ;``
| ``constexpr mapping(mapping const&) noexcept ;``
| ``mapping& operator=(mapping&&) noexcept ;``
| ``mapping& operator=(mapping const&) noexcept ;``
|  
| ``template <typename... IntegralExtent>``
| ``explicit constexpr mapping( IntegralExtent... ) noexcept;``
| ``explicit constexpr mapping( layout_concept const&) noexcept;``
|
| ``~mapping() noexcept ;``

  Constructors, assignment operators, and destructor requires and effects
  correspond to the corresponding members of ``array_ref`` .

| ``static constexpr int rank() noexcept;
| ``static constexpr int rank_dynamic() noexcept;
| ``constexpr size_type size() const noexcept;
| ``constexpr size_type extent(int) const noexcept;
| ``constexpr size_type static_extent(int) noexcept;
| ``constexpr size_type span() const noexcept;
|
| ``template <typename... IntegralExtent>
| ``static constexpr size_type required_span( IntegralExtent ... ) noexcept;
| ``static constexpr size_type required_span( layout_concept const & ) noexcept;
|
| ``static constexpr bool is_always_unique     = /* deduced */ ;
| ``static constexpr bool is_always_contiguous = /* deduced */ ;
| ``static constexpr bool is_always_regular    = /* deduced */ ;
|
| ``constexpr bool is_unique() const noexcept;
| ``constexpr bool is_contiguous() const noexcept;
| ``constexpr bool is_regular() noexcept;
| 
| ``constexpr size_type stride(int) const noexcept;

  Domain, codomain, and mapping observers requires and effects
  correspond to the corresponding members of ``array_ref`` .

| ``template <typename... IntegralIndex>
| ``constexpr size_type operator()(IntegralIndex...index) const noexcept;
  
  Requires: ``rank() == sizeof...(IntegralIndex)`` and
  ``0 <= index[ith] < extent(ith)``.

  Returns: Layout mapping of ``index...`` to codomain.

| ``using iterator               = /* dereferences to size_type */ ;``
| ``using const_iterator         = /* dereferences to size_type */ ;``
| ``using reverse_iterator       = reverse_iterator<iterator> ;``
| ``using const_reverse_iterator = reverse_iterator<const_iterator> ;``
|
| ``constexpr iterator begin() const noexcept ;``
| ``constexpr iterator end()   const noexcept ;``
| ``constexpr const_iterator cbegin() const noexcept ;``
| ``constexpr const_iterator cend()   const noexcept ;``
| ``constexpr reverse_iterator rbegin() const noexcept ;``
| ``constexpr reverse_iterator rend()   const noexcept ;``
| ``constexpr const_reverse_iterator crbegin() const noexcept ;``
| ``constexpr const_reverse_iterator crend()   const noexcept ;``

  Iteration support analoguous to iteration support in ``array_ref`` .


----------------------------------------------------------------------------
``extents`` class for less desired extents specification mechanism (B)
----------------------------------------------------------------------------

.. code-block:: c++

  namespace std {
  namespace experimental {
  
    template< size_t ... IntegralExtent >
    struct extents {

      static constexpr int rank() noexcept;
      static constexpr int rank_dynamic() noexcept;

      static constexpr size_t static_extent(int) noexcept ;
    };

    constexpr size_t dyn = 0 ; // or ~size_t(0)
  
  }}
 
..

  Effects:
  | ``IntegralExtent == dyn`` indicates a dynamic extent.
  | ``rank() == sizeof...(IntegralExtent)``
  | ``rank_dynamic()`` is the number of dynamic extents.
  | ``static_extent(r) == IntegralExtent[r]``


----------------------------------------------------------------------------
``bounds_check_if< bool >``
----------------------------------------------------------------------------

| ``template< bool Enable > struct bounds_check_if ;``
| ``using bounds_check = bounds_check<true> ;``

  When ``array_ref`` ``Properties...`` includes
  ``bounds_check_if<true>`` then the mapping operators
  ``array_ref::operator()`` and ``array_ref::operator[]``
  verify that each index is valid,
  ``0 <= indices[ith] < extent(ith)``.
  Verification failure shall be reported.


