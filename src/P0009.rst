===================================================================
P0009r01 ``Polymorphic Multidimensional Array View``
===================================================================

:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Christian Trott
:Contact: crtrott@sandia.gov
:Author: Juan Alday
:Contact: juanalday@gmail.com
:Author: Jesse Perla
:Contact: jesse.perla@ubc.ca
:Author: Mauro Bianco
:Contact: mbianco@cscs.ch
:Author: Agustín K-ballo Bergé 
:Contact: kaballo86@hotmail.com
:Author: Maffeo, Robin 
:Contact: Robin.Maffeo@amd.com
:Author: Bryce Lelbach 
:Contact: balelbach@lbl.gov
:Date: 2015-06-26
:Version: 01
:URL: https://github.com/kokkos/PolyView/blob/master/src/P0009.rst

---------
Rationale
---------

Multidimensional arrays are a foundational data structure
for science and engineering codes, as demonstrated by their
extensive use in FORTRAN for five decades.
A multidimensional array is a **view** to a memory extent
through a **layout** mapping from a multi-index space (domain) to that extent (range).
A view's layout mapping may be bijective as in the case of a traditional
multidimensional array, injective as in the case of a subarray, or
surjective to express symmetry.

Traditional layout mappings have been specfied as part of the language.
For example, FORTRAN specifies *column major* layout and C specifies *row major* layout.
Such a language-imposed specification requires signficant code refactoring
to change an array's layout, and requires significant code complexity to
implement non-traditional layouts such as tiling in modern linear algebra
or structured grid application domains.  Such layout changes are required
to adapt and optimize code for varying computer architectures; for example,
to change a code from *array of structures* to *structure of arrays*.
Furthermore, multiple versions of code must be maintained for each required layout.

A multidimensional array view abstraction with polymorphic layout is required
to enable changing array layout without extensive code refactoring and
maintenance of functionally redundant code.
Layout polymorphism is a critical capability; however, it is not the only
beneficial form of polymorphism.

--------
The View
--------

The proposed **view** has template arguments for the data type of the array
and a parameter pack for polymorphic properties of the view.


.. code-block:: c++

  namespace std {
  namespace experimental {
    template< class DataType , class ... Properties >
    struct view ;
  }
  }

..


The complete proposed specification for **view** is
included at the end of this paper.
We present the specification incrementally to
convey the rational for this specification.

-----------------------------------------------
(1) View of a One-Dimensional Array
-----------------------------------------------

A view of a one-dimension array is anticipated to subsume the functionality
of a pointer to memory extent combined with an array length.
For example, a one-dimensional array is passed to a function as follows.

.. code-block:: c++

  // Traditional API
  void foo( int array[] , size_t N );
  void foo( const int array[] , size_t N );

  // Corresponding view API
  void foo( view< int[] > array );
  void foo( view< const int[] > array );

..

For this functionality the simple one-dimensional view interface requires the following.

.. code-block:: c++

  template< class DataType , class ... Properties >
  struct view {
    using value_type = // implementation defined
    using reference  = // implementation defined
    using pointer    = // implementation defined
    constexpr size_t size() const ;
    constexpr size_t extent() const ;
    template< typename t0 >
    reference operator[]( const t0 & i0 ) const ;
    constexpr view( pointer , size_t );
    constexpr view();
  };

..

The *const-ness* of a view is analogous to the *const-ness* of a pointer.
A const-view is similar to a const-pointer in that the view may not be
modifid but the viewed extent of memory may be modified.
A view-of-const is similar to a pointer-to-const in that the viewed
extent of memory may not be modified.

**constexpr extent() const ;**

  Returns the extent of the index space.

  Discussion: Note the correlation between the extent of the view's data type and the
  extent of an instance of that view.

.. code-block:: c++
  using T = int[] ;
  view<T> x ;
  view<T> y( ptr , N );
  assert( 0 == std::extent<T>::value );
  assert( 0 == x.extent() );
  assert( N == y.extent() );
..

**template< typename t0 > reference operator[]( const t0 & i0 ) const ;**

  Returns a reference to the member identified with the index **i0**.

  Requires the *rank* of the array (number of dimension) to be one.

  Requires the index **i0** to be within the domain of the index space; i.e., [0..N).

-----------------------------------------------------------------------
(2) View of Traditional Multidimensional Array with Explicit Dimensions
-----------------------------------------------------------------------

A traditional multidimensional array with explicit dimensions
(for example, an array of 3x3 tensors) is passed to a function as follows.

.. code-block:: c++

  // Traditional API
  void foo( double array[][3][3] , size_t N0 );

  // View API
  template< typename T >
  void foo( view< double[][3][3] > array );

..

The view interface now requires the following.

.. code-block:: c++

  template< class DataType , class ... Properties >
  struct view {
    using value_type = // implementation defined
    using reference  = // implementation defined
    using pointer    = // implementation defined
    static constexpr unsigned rank = // rank of the array
    constexpr size_t  size() const ;
    constexpr size_t  extent() const ;
    constexpr size_t  extent_0() const ;
    constexpr size_t  extent_1() const ;
    constexpr size_t  extent_2() const ;
    template< typename t0 , typename t1 , typename t2 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2 ) const ;
    constexpr view( pointer , size_t );
    constexpr view();
  };

..

**static constexpr unsigned  rank**

  Is the rank of the multidimensional array.
  In this tensor example the rank is 3.

**constexpr size_t extent() const;**

  Returns the cardinality of the multidimensional array index space.
  In this tensor example example the cardinality is N0 * 3 * 3.

**constexpr size_t extent_#() const;**

  Returns the extent of the #th dimension.

  Discussion: This method could have other intuitive names, for example **dimension_#()**.

**constexpr size_t size() const;**

  Returns the distance between the first and last member of the multidimensional array.

  Discussion:  When the viewed array members are contigous and the mapping is
  bijective then **extent()** and **size()** are equal.
  If the members are non-contigous or the mapping is surjective then
  **extent()** and **size()** will not be equal.

::

  template< typename t0 , typename t1 , typename t2 >
  reference operator()( const t0 & i0
                      , const t1 & i1
                      , const t2 & i2 ) const ;

..

  Returns a *reference* to the array member referenced by the multi-index (i0,i1,i2).

  Requires std::is_integral<t#>::value.  Requirement is enforced via static_assert.

  Requires 0 <= i# < dimension_1().  Requirement may be enforced if array bounds checking is enabled.

  The dereferencing operator is templated on its argument types to defer promotion of the
  integral arguments to the internal implementation of the mapping expression from multi-index to
  a member reference.
  We defer integral type promotion to this implementation to maximize opportunity for
  optimization of this mapping expression.

--------------------------------------------------------------------
(3) View of Multidimensional Array with Multiple Implicit Dimensions
--------------------------------------------------------------------

Multidimensional arrays are used with multiple implicit dimensions;
i.e., more dimensions than the leading dimension are declared at runtime.
Such arrays are implemented within applications and libraries with
numerous design idioms.

A minimalist design that preserves the appearance of conventional
multidimensional array syntax follows an *array of pointers to array of pointers to ...* idiom.
While dereferencing operations are syntactically compatible with
an array of explicitly declared dimensions this idiom provides
no locality guarantees for members of the array,
consumes significant memory for the arrays of pointers,
and is problematic when passing such arrays to functions.

.. code-block:: c++

  double *** x ;
  x = new double **[N0];
  for ( size_t i0 = 0 ; i0 < N0 ; ++i0 ) {
    x[i0] = new double *[N1];
    for ( size_t i1 = 0 ; i1 < N1 ; ++i1 ) {
      x[i0][i1] = new double[N2] ;
    }
  }

  x[i0][i1][i2] // member access

  foo( double *const *const array[] , size_t N0 , size_t N1 , size_t N2 );

..

A major goal of the **view** interface is to preserve
compatibility between views to arrays
with explicit and implicitly declared dimensions.
In the following example foo1 and foo2 accept rank 3 arrays of integers
with prescribed explicit / implicit dimensions and fooT accepts a rank 3
array of integers with unprescribed dimensions.

.. code-block:: c++

  void foo1( view< int[ ][3][3] > array ); // Explicit dimensions #1 and #2
  void foo2( view< int[ ][ ][ ] > array ); // All implicit dimensions

  // Accept a rank three array of value type int
  // where dimensions are explicit or implicit
  template< size_t N0 , size_t N1 , size_t N2 >
  void fooT( view< int[N0][N1][N2] > array );

  // template matching requires:
  // N0 == std::extent< int[][][] , 0 >::value
  // N1 == std::extent< int[][][] , 1 >::value
  // N2 == std::extent< int[][][] , 2 >::value

  // If the explicit dimensions are non-zero then the corresponding
  // extents must be equal to these dimensions.
  assert( N0 == 0 || N0 == array.extent_0() );
  assert( N1 == 0 || N1 == array.extent_0() );
  assert( N2 == 0 || N2 == array.extent_0() );

..

This syntax requires a relaxation of array type declarator constraints defined in **8.3.4 Arrays paragraph 3**.
Note that this existing specification is in error when array syntax is used in a type definition.

  When several “array of” specifications are adjacent,
  a multidimensional array is created;
  only the first of the constant expressions
  that specify the bounds of the arrays may be omitted.

.. code-block:: c++

  typedef int X[][3][3] ; // does not create a multidimensional array
  using Y = int[][3][3] ; // does not create a multidimensional array

..

Changing the **8.3.4.p3** constraint as follows would allow the proposed syntax for a view of an array
with multiple implicit dimensions, and preserve correctness for conventional array declarations.

  When several “array of” specifications are adjacent
  to form a multidimensional array type specification
  only the first of the sequence of array bound constant expressions
  may be omitted for types used in the explicit declaration of a multidimensional array;
  otherwise any or all of the array bound constant expressions may be omitted.

Support for multiple implicit dimensions the view requires a constructor
with a value for each implicit dimension.

.. code-block:: c++

  template< class DataType , class ... Properties >
  struct view {
    constexpr view( pointer , size_t N0 , size_t N1 , size_t N2 );
  };

..


--------------------------------------------------------------------
(4) Layout Polymorphism
--------------------------------------------------------------------






--------------------------------------------------------------------
Specification
--------------------------------------------------------------------

.. code-block:: c++

  namespace std {
  namespace experimental {
  template< class DataType , class ... Properties >
  struct view {
    //--------------------
    // Types:

    // Types are implementation and Properties dependent.
    // The following types are normative for empty Properties.

    using value_type = typename std::remove_all_extents< DataType >::type ;
    using reference  = value_type & ;
    using pointer    = value_type * ;

    //--------------------
    // Properties:

    static constexpr unsigned rank = std::rank<DataType>::value ;

    constexpr size_t  size() const ;

    // Rank upper bound is at least ten.
    constexpr size_t  extent() const ;
    constexpr size_t  extent_0() const ;
    constexpr size_t  extent_1() const ;
    constexpr size_t  extent_2() const ;
    constexpr size_t  extent_3() const ;
    constexpr size_t  extent_4() const ;
    constexpr size_t  extent_5() const ;
    constexpr size_t  extent_6() const ;
    constexpr size_t  extent_7() const ;
    constexpr size_t  extent_8() const ;
    constexpr size_t  extent_9() const ;

    //--------------------
    // Member access (proper):

    // Requires rank == 1 and std::is_integral<t0>::value
    template< typename t0 >
    reference operator[]( const t0 & i0 ) const ;

    // Requires rank == 0
    reference operator() const ;

    // Requires rank == 1 and std::is_integral<t0>::value
    template< typename t0 >
    reference operator()( const t0 & i0 ) const ;

    // Requires rank == 2 and std::is_integral<t#>::value
    template< typename t0 , typename t1 >
    reference operator()( const t0 & i0
                        , const t1 & i1 ) const ;

    // Requires rank == 3 and std::is_integral<t#>::value
    template< typename t0 , typename t1 , typename t2 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2 ) const ;

    // member access operator follows pattern through at least rank ten.

    // Requires rank == 10 and std::is_integral<t#>::value
    template< typename t0 , typename t1 , typename t2 , typename t3 , typename t4
            , typename t5 , typename t6 , typename t7 , typename t8 , typename t9 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2
                        , const t3 & i3
                        , const t4 & i4
                        , const t5 & i5
                        , const t6 & i6
                        , const t7 & i7
                        , const t8 & i8
                        , const t9 & i9
                        ) const ;

    //--------------------
    // Member access (improper):

    // Requires rank == 0 and i# == 0
    reference operator()( const int i0 = 0
                        , const int i1 = 0
                        , const int i2 = 0
                        , const int i3 = 0
                        , const int i4 = 0
                        , const int i5 = 0
                        , const int i6 = 0
                        , const int i7 = 0
                        , const int i8 = 0
                        , const int i9 = 0
                        ) const ;

    // Requires rank == 1 and std::is_integral<t0>::value and i{1-9} == 0
    template< typename t0 >
    reference operator()( const t0 & i0
                        , const int i1 = 0
                        , const int i2 = 0
                        , const int i3 = 0
                        , const int i4 = 0
                        , const int i5 = 0
                        , const int i6 = 0
                        , const int i7 = 0
                        , const int i8 = 0
                        , const int i9 = 0
                        ) const ;

    // improper member access operator follows pattern through at least rank nine.

    // Requires rank == 10 and std::is_integral<t{0-8}>::value and i9 == 0
    template< typename t0 , typename t1 , typename t2 , typename t3 , typename t4
            , typename t5 , typename t6 , typename t7 , typename t8 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2
                        , const t3 & i3
                        , const t4 & i4
                        , const t5 & i5
                        , const t6 & i6
                        , const t7 & i7
                        , const t8 & i8
                        , const int i9 = 0
                        ) const ;

    //--------------------
    // Construct/copy/destroy:

    ~view();
    constexpr view();
    constexpr view( const view & );
    constexpr view( view && );
    view & operator = ( const view & );
    view & operator = ( view && );

    constexpr view( pointer
                  , size_t implicit_N0 = 0
                  , size_t implicit_N1 = 0
                  , size_t implicit_N2 = 0
                  , size_t implicit_N3 = 0
                  , size_t implicit_N4 = 0
                  , size_t implicit_N5 = 0
                  , size_t implicit_N6 = 0
                  , size_t implicit_N7 = 0
                  , size_t implicit_N8 = 0
                  , size_t implicit_N9 = 0
                  );

    template< class UType , class ... UProperties >
    constexpr view( const view< UType , UProperties ... > & );

    template< class UType , class ... UProperties >
    view & operator = ( const view< UType , UProperties ... > & );
  };
  }
  }

..





