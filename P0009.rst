===================================================================
P0009r01 ``Polymorphic Multidimensional Array View``
===================================================================

:Author: H\. Carter Edwards
:Contact: hcedwar@sandia.gov
:Author: Christian Trott
:Contact: crtrott@sandia.gov
:Author: Juan Alday
:Contact: juanalday@gmail.com
:Author: Jesse Perla
:Contact: jesse.perla@ubc.ca
:Author: Mauro Bianco
:Contact: mbianco@cscs.ch
:Author: Agustín K-ballo Bergé 
:Contact: kaballo86@hotmail.com
:Author: Maffeo, Robin 
:Contact: Robin.Maffeo@amd.com
:Author: Bryce Lelbach 
:Contact: balelbach@lbl.gov
:Date: 2015-06-26
:Version: 01
:URL: https://github.com/kokkos/PolyView/blob/master/P0009.rst
:WG21: Library Evolution
:WG21: Evolution (array declaration)

.. sectnum::

---------
Rationale
---------

Multidimensional arrays are a foundational data structure
for science and engineering codes, as demonstrated by their
extensive use in FORTRAN for five decades.
A multidimensional array is a **view** to a memory extent
through a **layout** mapping from a multi-index space (domain) to that extent (range).
A view's layout mapping may be bijective as in the case of a traditional
multidimensional array, injective as in the case of a subarray, or
surjective to express symmetry.

Traditional layout mappings have been specfied as part of the language.
For example, FORTRAN specifies *column major* layout and C specifies *row major* layout.
Such a language-imposed specification requires signficant code refactoring
to change an array's layout, and requires significant code complexity to
implement non-traditional layouts such as tiling in modern linear algebra
or structured grid application domains.  Such layout changes are required
to adapt and optimize code for varying computer architectures; for example,
to change a code from *array of structures* to *structure of arrays*.
Furthermore, multiple versions of code must be maintained for each required layout.

A multidimensional array view abstraction with polymorphic layout is required
to enable changing array layout without extensive code refactoring and
maintenance of functionally redundant code.
Layout polymorphism is a critical capability; however, it is not the only
beneficial form of polymorphism.

--------
The View
--------

The proposed **view** has template arguments for the data type of the array
and a parameter pack for polymorphic properties of the view.


.. code-block:: c++

  namespace std {
  namespace experimental {
    template< class DataType , class ... Properties >
    struct view ;
  }
  }

..


The complete proposed specification for **view** is
included at the end of this paper.
We present the specification incrementally to
convey the rational for this specification.

-----------------------------------------------
View of a One-Dimensional Array
-----------------------------------------------

A view of a one-dimension array is anticipated to subsume the functionality
of a pointer to memory extent combined with an array length.
For example, a one-dimensional array is passed to a function as follows.

.. code-block:: c++

  // Traditional API
  void foo( int array[] , size_t N );
  void foo( const int array[] , size_t N );

  // Corresponding view API
  void foo( view< int[] > array );
  void foo( view< const int[] > array );

..

For this functionality the simple one-dimensional view interface requires the following.

.. code-block:: c++

  template< class DataType , class ... Properties >
  struct view {
    using value_type = // implementation defined
    using reference  = // implementation defined
    using pointer    = // implementation defined
    constexpr size_t size() const ;
    constexpr size_t extent_0() const ;

    template< typename t0 >
    reference operator[]( const t0 & i0 ) const ;
    constexpr view( pointer , size_t );

    constexpr view();
    constexpr view( const view & );
    constexpr view( view && );
    view & operator =( const view & );
    view & operator =( view && );

    template< class T , class ... P >
    constexpr view( const view< T , P ... > & );
  };

..

The *const-ness* of a view is analogous to the *const-ness* of a pointer.
A const-view is similar to a const-pointer in that the view may not be
modifid but the viewed extent of memory may be modified.
A view-of-const is similar to a pointer-to-const in that the viewed
extent of memory may not be modified.

**constexpr size() const ;**

  Returns the cardinality of the index space.

**constexpr extent_0() const ;**

  Returns the extent of the 0th dimension of the index space.

  Discussion: Note the correlation between the extent of the view's data type and the
  extent of an instance of that view.
  The non-template member function **x.extent_0()** is prefered over an
  functionality equivalent template member function **x.template extent<0>()**
  for syntactic conciseness.

.. code-block:: c++
  using T = int[] ;
  view<T> x ;
  view<T> y( ptr , N );
  assert( 0 == std::extent<T,0>::value );
  assert( 0 == x.extent_0() );
  assert( N == y.extent_0() );
..

**template< typename t0 > reference operator[]( const t0 & i0 ) const ;**

  Returns a reference to the member identified with the index **i0**.

  Requires the *rank* of the array (number of dimension) to be one.

  Requires the index **i0** to be within the domain of the index space; i.e., [0..N).

**constexpr view( pointer p , size_t n )**

  Effects: Construct view object for the memory span [ p .. p + n )

  Requires: The memory span [ p .. p + n ) is valid to view as an array.

**template< class T , class ... P > constexpr view( const view< T , P ... > & )**

  Effects: Construct view object from an assignable view.

  This view and the input view must be assignable with respect to their data type
  (e.g., const assigned from non-const) and array properties (e.g., same rank).

----------------------------------------------------------------------------
View of Traditional Multidimensional Array with Explicit Dimensions
----------------------------------------------------------------------------

A traditional multidimensional array with explicit dimensions
(for example, an array of 3x3 tensors) is passed to a function as follows.

.. code-block:: c++

  void foo( double array[][3][3] , size_t N0 ); // Traditional API

  void foo( view< double[][3][3] > array ); // View API

..

The view interface now requires the following.

.. code-block:: c++

  template< class DataType , class ... Properties >
  struct view {
    using value_type = // implementation defined
    using reference  = // implementation defined
    using pointer    = // implementation defined
    static constexpr unsigned rank() { return std::rank<DataType>::value ; }
    constexpr size_t  extent_0() const ;
    constexpr size_t  extent_1() const ;
    constexpr size_t  extent_2() const ;
    template< unsigned > constexpr size_t extent() const ;
    constexpr size_t  size() const ;
    constexpr size_t  span() const ;
    template< typename t0 , typename t1 , typename t2 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2 ) const ;
    constexpr view( pointer , size_t );
  };

..

**static constexpr unsigned  rank()**

  Returns the rank of the multidimensional array.  Conformal to std::rank< DataType >::value.

**constexpr size_t extent_#() const;**

  Returns the extent of the #th dimension.

  Discussion:
  For an explicit dimension extent_#() is simply std::extent<DataType,#>::value.
  For an implicit dimension extent_#() returns the runtime declared value for dimension #.
  This member function is not templated due to persistent feedback on the usability of **view**
  within functions that are templated on the **view** type.
  Given a reasonable upper bound on the rank this usability preference has not been an issue.

.. code-block:: c++

  template< class T , class ... P >
  void foo( const view<T,P...> x )
    {
      size_t const n0 = x.extent_0();           // preferred by common users
      size_t const n0 = x.template extent<0>(); // disliked by common users
    }

..

**template< unsigned > constexpr size_t extent() const;**

  Returns the extent of the #th dimension where # is given as a template argument.

  Discussion:
  For libraries that are parameterized on the rank of multidimensional array views
  require parameterized access to extents.
  This serves a distinctly different user community and usage scenarios
  than the previous **extent_#()** interface.


**constexpr size_t size() const;**

  Returns the cardinality of the multidimensional array index space.
  
  Discussion: Equal to the product of the extents.

**constexpr size_t span() const;**

  Returns one plus the maximum distance between any two members of the view.

  Discussion:  When the viewed array members are contigous and the mapping is
  bijective then **size()** and **span()** are equal.
  If the members are non-contigous or the mapping is surjective then
  **size()** and **span()** will not be equal.

**reference operator()(...) const;**

.. code-block:: c++

  template< typename t0 , typename t1 , typename t2 >
  reference operator()( const t0 & i0
                      , const t1 & i1
                      , const t2 & i2 ) const ;

..

  Returns a *reference* to the array member referenced by the multi-index (i0,i1,i2).

  Requires std::is_integral<t#>::value.  Requirement is enforced via static_assert.

  Requires 0 <= i# < extent_#().  Requirement may be enforced if array bounds checking is enabled.

  Discussion: 
  The *operator()* is templated on its argument types to defer promotion of the
  integral arguments to the internal implementation of the mapping expression from multi-index to
  a member reference.
  We defer integral type promotion to this implementation to maximize opportunity for
  optimization of this mapping expression.

----------------------------------------------------------------------------
View of Multidimensional Array with Multiple Implicit Dimensions (Preferred)
----------------------------------------------------------------------------

**Requires language change for slight relaxation of array declaration.**

Multidimensional arrays are used with multiple implicit dimensions;
i.e., more dimensions than the leading dimension are declared at runtime.
Such arrays are implemented within applications and libraries with
numerous design idioms.

A minimalist design that preserves the appearance of conventional
multidimensional array syntax follows an *array of pointers to array of pointers to ...* idiom.
While dereferencing operations are syntactically compatible with
an array of explicitly declared dimensions this idiom provides
no locality guarantees for members of the array,
consumes significant memory for the arrays of pointers,
and is problematic when passing such arrays to functions.

.. code-block:: c++

  double *** x ;
  x = new double **[N0];
  for ( size_t i0 = 0 ; i0 < N0 ; ++i0 ) {
    x[i0] = new double *[N1];
    for ( size_t i1 = 0 ; i1 < N1 ; ++i1 ) {
      x[i0][i1] = new double[N2] ;
    }
  }

  x[i0][i1][i2] // member access

  foo( double *const *const array[] , size_t N0 , size_t N1 , size_t N2 );

..

A major goal of the **view** interface is to preserve compatibility
between views to arrays with explicit and implicitly declared dimensions.
In the following example foo1 and foo2 accept rank 3 arrays of integers
with prescribed explicit / implicit dimensions and fooT accepts a rank 3
array of integers with unprescribed dimensions.

.. code-block:: c++

  void foo1( view< int[ ][3][3] > array ); // Explicit dimensions #1 and #2
  void foo2( view< int[ ][ ][ ] > array ); // All implicit dimensions

  // Accept a view of a rank three array with value type int
  // and dimensions are explicit or implicit.
  template< class T , class ... P >
  typename std::enable_if< view<T,P...>::rank() == 3 >::type
  fooT( view<T,P...> array );

..

This syntax requires a relaxation of array type declarator constraints defined in **8.3.4 Arrays paragraph 3**.
*When several “array of” specifications are adjacent,
a multidimensional array is created;
only the first of the constant expressions
that specify the bounds of the arrays may be omitted.*
Note that this existing specification is in error when array syntax is used in a type definition.

.. code-block:: c++

  typedef int X[][3][3] ; // does not create a multidimensional array
  using Y = int[][3][3] ; // does not create a multidimensional array

..

Note that this is a simple one-line change in Clang to disable the error message.

Note that gcc 4.7, 4.8, and 4.9 implicitly support such types as
demonstrated by the following error-free and warning-free meta function.

.. code-block:: c++

  template< typename T , unsigned R >
  struct implicit_array_type { using type = typename implicit_array_type<T,R-1>::type[] ; };

  template< typename T >
  struct implicit_array_type<T,0> { using type = T ; };

  using array_rank_3 = typename implicit_array_type<int,3>::type ;

..


Changing the **8.3.4.p3** constraint as follows would allow the proposed syntax for a view of an array
with multiple implicit dimensions, and preserve correctness for conventional array declarations.
*When several “array of” specifications are adjacent
to form a multidimensional array type specification
only the first of the sequence of array bound constant expressions
may be omitted for types used in the explicit declaration of a multidimensional array;
otherwise any or all of the array bound constant expressions may be omitted.*

Note that there exists at least two precedents for types that can be defined but not used to declare objects:
(1) an array with an ommitted leading bound and (2) **void**.


A view constructor with arguments for each implicit dimension is now required.

.. code-block:: c++

  template< class DataType , class ... Properties >
  struct view {
    constexpr view( pointer
                  , size_t implicit_N0
                  , size_t implicit_N1
                  , size_t implicit_N2
                  /* etc */
                  );
  };

.. /*

------------------------------------------------------------------------------
View of Multidimensional Array with Multiple Implicit Dimensions (alternative)
------------------------------------------------------------------------------

If the array declaration constraint in **8.3.4.p3** cannot be relaxed then
an alternative mechanism is required to define mixed explicit and implicit
dimensions through a view dimension property.
A dimension property is syntactically more verbose and requires the
"magic value" zero to denote an implicit dimension.
The "magic value" of zero is chosen for consistency with **std::extent**.

.. code-block:: c++

  std::view< int[][][3] > x(ptr,N0,N1);                       // preferred concise syntax
  std::view< int , std::view_dimension<0,0,3> > y(ptr,N0,N1); // verbose syntax

  assert( extent< int[][][3] , 0 >::value == 0 );
  assert( extent< int[][][3] , 1 >::value == 0 );
  assert( extent< int[][][3] , 2 >::value == 3 );

  assert( view_dimension<0,0,3>::extent_0 == 0 );
  assert( view_dimension<0,0,3>::extent_1 == 0 );
  assert( view_dimension<0,0,3>::extent_2 == 3 );

  assert( x.extent_0() == N0 );
  assert( x.extent_1() == N1 );
  assert( x.extent_2() == 3 );

  assert( y.extent_0() == N0 );
  assert( y.extent_1() == N1 );
  assert( y.extent_2() == 3 );

..

If this aternative mechanism is required the array declaration syntax
will still be available when only the leading dimension is implicit.

.. code-block:: c++

  std::view< int[] > x ;                        // concise syntax
  std::view< int , std::view_dimension<0> > y ; // property syntax

..

A similar mechanism may be defined to declare a view to array
of rank **R** with all-implicit dimension.

.. code-block:: c++

  std::view< int , std::view_rank<R> > z ;

..

--------------------------------------------------------------------
Layout Polymorphism
--------------------------------------------------------------------

The **view::operator()** maps the input multi-index from the array's
cartesian product multi-index *domain* space to a member in the array's *range* space.
This is the **layout** mapping for the viewed array.
For natively declared multidimensional arrays the layout mapping
is defined to conform to treating the multidimensional array as
an *array of arrays of arrays ...*; i.e., the size and span are
equal and the strides increase from right-to-left.
In the FORTRAN language defines layout mapping with strides
increasing from left-to-right.
These *native* layout mappings are only two of many possible layouts.
For example, the *basic linear algebra subprograms (BLAS)* standard
defines dense matrix layout mapping with padding of the leading dimension,
requiring both dimensions and **LDA** parameters to fully declare a matrix layout.


A view property template parameter specifies a layout mapping.
If this property is ommitted the layout mapping of the view 
conforms to a corresponding natively declared multidimensional array
as if implicit dimensions were declared explicitly.
The default layout is *regular* - the distance is constant between
entries when a single index of the multi-index is incremented.
This distance is the *stride* of the corresponding dimension.
In the default layout mapping is bijective and the stride increases
monotonically from the right most to the left most dimension.

.. code-block:: c++

  // The default layout mapping of a rank-four multidimensional
  // array is as if implemented as follows.

  template< size_t N0 , size_t N1 , size_t N2 , size_t N4 >
  size_t native_mapping( size_t i0 , size_t i1 , size_t i2 , size_t i3 )
    {
      return i0 * N3 * N2 * N1 // stride == N3 * N2 * N1
           + i1 * N3 * N2      // stride == N3 * N2
           + i2 * N3           // stride == N3
           + i3 ;              // stride == 1
    } 

..

An initial set of layout specifications are
**view_layout_right**, **view_layout_left**, and **view_layout_stride**.

.. code-block:: c++

  namespace std {
  namespace experimental {
    struct view_layout_right ;
    struct view_layout_left ;
    struct view_layout_stride ;
  }}

..

A view_layout_right mapping is regular and injective with
strides increasing from right most to left most dimension.
A view_layout_left mapping is regular and injective with
strides increasing from left most to right most dimension.
A view_layout_stride mapping is regular; however, it may
not be injective or surjective.

.. code-block:: c++

  // The right and left layout mapping of a rank-four multidimensional
  // array is as if implemented as follows.

  template< size_t N0 , size_t N1 , size_t N2 , size_t N4 >
  size_t right_mapping( size_t i0 , size_t i1 , size_t i2 , size_t i3 )
    {
      const size_t S3 = // stride of dimension #3
      const size_t P3 = // padding of dimension #3
      const size_t P2 = // padding of dimension #2
      const size_t P1 = // padding of dimension #1
      return i0 * S3 * ( P3 + N3 ) * ( P2 + N2 ) * ( P1 + N1 )
           + i1 * S3 * ( P3 + N3 ) * ( P2 + N2 )
           + i2 * S3 * ( P3 + N3 )
           + i3 * S3 ;
    }

  template< size_t N0 , size_t N1 , size_t N2 , size_t N4 >
  size_t left_mapping( size_t i0 , size_t i1 , size_t i2 , size_t i3 )
    {
      const size_t S0 = // stride of dimension #0
      const size_t P0 = // padding of dimension #0
      const size_t P1 = // padding of dimension #1
      const size_t P2 = // padding of dimension #2
      return i0 * S0
           + i1 * S0 * ( P0 + N0 )
           + i2 * S0 * ( P0 + N0 ) * ( P1 + N1 )
           + i3 * S0 * ( P0 + N0 ) * ( P1 + N1 ) * ( P2 + N2 );
    }

..


The view interface has the following additions for layout polymorphism.

.. code-block:: c++

  template< typename DataType , class ... Properties >
  struct view {
    using layout     = // implementation defined
    using is_regular = std::integral_constant<bool, /* implementation defined*/ > ;
    constexpr size_t stride_0() const ;
    constexpr size_t stride_1() const ;
    constexpr size_t stride_2() const ;
    constexpr size_t stride_3() const ;
    // etc.
  };

..

**using layout = ... ;**

  Declares the layout property.
  If the Properties pack does not include a layout property the type alias is **void**.

**using is_regular = std::integral_constant<bool, ... > ;**

  Declares whether the layout mapping is regular.
  A regular layout mapping is injective and has uniform striding for each dimension.

**constexpr size_t stride_#() const ;**

  Returns the stride of the # dimension of a view with regular layout mapping.
  If the layout mapping is not regular returns zero.


**View with layout == void (default)**

The layout mapping with a default layout conforms to the *native* layout mapping
as if all of the implicit dimensions had been explicit.
The default layout mapping is regular and bijective; i.e., has size() == span().

.. code-block:: c++

  view< int[][][] > x( x_ptr , N0 , N1 , N2 )

  assert( x.span() == x.size() );

  assert( std::distance( & x(i0,i1,i2) , & x(0,0,0) ) ==
          ( i0 * x.extent_1() + i1 ) * x.extent_2() + i2 );

  assert( x.stride_2() == 1 );
  assert( x.stride_1() == x.extent_2() * x.stride_2() );
  assert( x.stride_0() == x.extent_1() * x.stride_1() );

..


**View with layout == view_layout_right**

A view_layout_right mapping is regular and is similar to the default mapping
in that the strides increase from right-to-left dimensions.
The view_layout_right mapping deviates from the default mapping
in that an implementation is allowed to pad dimensions.

.. code-block:: c++

  view< int[][][] , view_layout_right > y( y_ptr , N0 , N1 , N2 );

  assert( y.span() <= y.size() );
  assert( y.span() == y.extent_0() * y.stride_0() );

  // 'padded_extent_#' private member for illustration only

  assert( std::distance( & y(i0,i1,i2) , & y(0,0,0) ) ==
          ( ( i0 * y.padded_extent_1 + i1 ) * y.padded_extent_2 + i2 ) * y.padded_extent_3 );

  assert( 1 <= y.padded_extent_3 );
  assert( y.padded_extent_2 <= y.extent_2() );
  assert( y.padded_extent_1 <= y.extent_1() );

  assert( y.stride_2() == y.padded_extent_3 );
  assert( y.stride_1() == y.padded_extent_2 * y.stride_2() );
  assert( y.stride_0() == y.padded_extent_1 * y.stride_1() );

..



**View with layout == view_layout_left**

A view_layout_left mapping is regular and its strides
increase from left-to-right dimensions.
An implementation is allowed to pad dimensions.

.. code-block:: c++

  view< int[][][] , view_layout_left > y( y_ptr , N0 , N1 , N2 );

  assert( y.span() <= y.size() );
  assert( y.span() == y.extent_2() * y.stride_2() );

  // 'padded_extent_#' private member for illustration only

  assert( std::distance( & y(i0,i1,i2) , & y(0,0,0) ) ==
          y.padded_extent * ( i0 + y.padded_extent_0 * ( i1 + y.padded_extent_1 * i2 ) ) );

  assert( 1 <= y.padded_extent );
  assert( y.padded_extent_0 <= y.extent_0() );
  assert( y.padded_extent_1 <= y.extent_1() );

  assert( y.stride_0() == y.padded_extent_0 * y.padded_extent );
  assert( y.stride_1() == y.padded_extent_1 * y.stride_0() );
  assert( y.stride_2() == y.padded_extent_2 * y.stride_1() );

..


**View with layout == view_layout_stride**

A view_layout_stride mapping is regular; however, the ordering of its strides is arbitrary.

.. code-block:: c++

  view< int[][][] , view_layout_stride > y( y_ptr , N0 , N1 , N2 );

  assert( y.span() <= y.size() );
  assert( y.span() == max( y.extent_0() * y.stride_0() ,
                      max( y.extent_1() * y.stride_1() ,
                           y.extent_2() * y.stride_2() ) );

  // 'padded_extent_#' private member for illustration only

  assert( std::distance( & y(i0,i1,i2) , & y(0,0,0) ) ==
          y.stride_0() * i0 + y.stride_1() * i1 + y.stride_2() * i2 );

..


--------------------------------------------------------------------
Extensible Layout Polymorphism
--------------------------------------------------------------------

The **view** is intended to be extensible such that a user may supply
a customized layout mapping.
A user supplied customized layout mapping will be required to conform
to a specified interface; *a.k.a.*, a C++ Concept.
Details of this extension point will be included in a subsequent
proposal.


An important customized layout mapping is hierarchical tiling.
This kind of layout mapping is used in dense linear algebra matrices and
computations on Cartesian grids to improve the spatial locality
of array entries.
These mappings are bijective but are not regular.
Computations on such multidimensional arrays typically iterate
through tiles as *subviews* of the array.

.. code-block:: c++

  template< size_t N0 , size_t N1 , size_t N2 >
  size_t tiling_left_mapping( size_t i0 , size_t i1 , size_t i2 )
  {
    static constexpr size_t T = // cube tile size
    constexpr size_t T0 = ( N0 + T - 1 ) / T ; // tiles in dimension 0
    constexpr size_t T1 = ( N1 + T - 1 ) / T ; // tiles in dimension 1
    constexpr size_t T2 = ( N2 + T - 1 ) / T ; // tiles in dimension 2

    // offset within tile + offset to tile
    return ( i0 % T ) + T * ( i1 % T ) + T * T * ( i2 % T )
         + T * T * T * ( ( i0 / T ) + T0 * ( ( i1 / T ) + T1 * ( i2 / T ) ) );
  }

..

--------------------------------------------------------------------
Subview of View
--------------------------------------------------------------------

.. code-block:: c++

namespace std {
namespace experimental {

  template< typename ViewType , class ... Indices_And_Ranges >
  struct subview_type ;

  template< typename ViewType , class ... Indices_And_Ranges >
  using subview_t = typename subview_type< ViewType , Indices_And_Ranges >::type ;

  template< typename DataType , class ... Parameters , class ... Indices_And_Ranges >
  subview_t< view< DataType, Parameters ... > , Indices_And_Ranges ... >
  subview( const view< DataType, Parameters ... > & , Indices_And_Ranges ... );

  template< typename T >
  struct is_integral_range ;

}}

..

The **subview_t** meta function and **subview** function requires
``sizeof...(Indices_And_Ranges) == view< DataType , Parameters... >::rank()``
and each member of **Indices_And_Ranges** to be either an integral type
or an integral range.
The rank of the resulting subview is the rank of the input view minus
the number of integral type arguments in **Indices_And_Ranges**.

.. code-block:: c++

  using U = view< int[][][] > ;

  U x(N0,N1,N2);

  // Using std::pair<int,int> for an integral range

  using V = subview_t< U , std::pair<int,int> , std::pair<int,int> , int > ;

  V y = subview( x , std::pair<int,int>(1,N0-1) , std::pair<int,int>(1,N1-1) , 1 );

  assert( y.rank() == 2 );
  assert( y.extent_0() == N0-2 );
  assert( y.extent_1() == N1-2 );
  assert( & y(0,0) == & x(1,1,1) );

  // Using initializer_list with size() == 2 as an integral range

  auto z = subview( x , 1 , {1,N1-1} , 1 );

  assert( z.rank() == 1 );
  assert( & z(0) == & x(1,1,1) );

..



--------------------------------------------------------------------
Specification with Simple View Properties
--------------------------------------------------------------------

Simple view properties include the array layout and if necessary 
a **view_dimension** type for arrays with multiple implicit dimensions.
View properties are provided through a variadic template to 
support extensibility of the view.
Possible additional properties include array bounds checking,
atomic access to members, memory space within a heterogeneous
memory architecture, and user access pattern hints.

One or more view properties of **void** are acceptable and have no effect.
This allows user code to define a template argument list of potential
view properties and then enabling/disabling a particular property by conditionally
setting it to **void**.


.. code-block:: c++

  namespace std {
  namespace experimental {

  template< class DataType , class ... Properties >
  struct view {
    //--------------------
    // Types:

    // Types are implementation and Properties dependent.
    // The following type implementation are normative 
    // with respect to empty Properties.

    using value_type = typename std::remove_all_extents< DataType >::type ;
    using reference  = value_type & ;
    using pointer    = value_type * ;

    //--------------------
    // Domain index space properties:

    static constexpr unsigned rank();

    // Rank upper bound is at least ten.
    constexpr size_t  extent_0() const ;
    constexpr size_t  extent_1() const ;
    constexpr size_t  extent_2() const ;
    constexpr size_t  extent_3() const ;
    constexpr size_t  extent_4() const ;
    constexpr size_t  extent_5() const ;
    constexpr size_t  extent_6() const ;
    constexpr size_t  extent_7() const ;
    constexpr size_t  extent_8() const ;
    constexpr size_t  extent_9() const ;

    template< unsigned > constexpr size_t extent() const ;

    // Cardinality of index space; i.e., product of extents
    constexpr size_t  size() const ;

    //--------------------
    // Layout mapping properties:

    using layout     = ... ;
    using is_regular = std::integral_constant<bool, ... > ;

    // If the layout mapping is regular then return the
    // distance between members when index # is increased by one.
    constexpr size_t  stride_0() const ;
    constexpr size_t  stride_1() const ;
    constexpr size_t  stride_2() const ;
    constexpr size_t  stride_3() const ;
    constexpr size_t  stride_4() const ;
    constexpr size_t  stride_5() const ;
    constexpr size_t  stride_6() const ;
    constexpr size_t  stride_7() const ;
    constexpr size_t  stride_8() const ;
    constexpr size_t  stride_9() const ;

    template< unsigned > constexpr size_t stride() const ;

    // One plus maximum distance between any two members.
    constexpr size_t span() const ;

    // Span of an array with regular layout if it
    // is constructed with the given implicit dimensions.
    static constexpr
      size_t span( size_t implicit_N0
                 , size_t implicit_N1 = 0
                 , size_t implicit_N2 = 0
                 , size_t implicit_N3 = 0
                 , size_t implicit_N4 = 0
                 , size_t implicit_N5 = 0
                 , size_t implicit_N6 = 0
                 , size_t implicit_N7 = 0
                 , size_t implicit_N8 = 0
                 , size_t implicit_N9 = 0
                 );

    // Pointer to member memory
    constexpr pointer data() const ;

    //--------------------
    // Member access (proper):

    // Requires rank == 0
    reference operator()() const ;

    // Requires rank == 1 and std::is_integral<t0>::value
    template< typename t0 >
    reference operator[]( const t0 & i0 ) const ;

    // Requires rank == 1 and std::is_integral<t0>::value
    template< typename t0 >
    reference operator()( const t0 & i0 ) const ;

    // Requires rank == 2 and std::is_integral<t#>::value
    template< typename t0 , typename t1 >
    reference operator()( const t0 & i0
                        , const t1 & i1 ) const ;

    // Requires rank == 3 and std::is_integral<t#>::value
    template< typename t0 , typename t1 , typename t2 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2 ) const ;

    // member access operator follows pattern through at least rank ten.

    // Requires rank == 10 and std::is_integral<t#>::value
    template< typename t0 , typename t1 , typename t2 , typename t3 , typename t4
            , typename t5 , typename t6 , typename t7 , typename t8 , typename t9 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2
                        , const t3 & i3
                        , const t4 & i4
                        , const t5 & i5
                        , const t6 & i6
                        , const t7 & i7
                        , const t8 & i8
                        , const t9 & i9
                        ) const ;

    //--------------------
    // Member access (improper):

    // Requires rank == 0 and i# == 0
    reference operator()( const int i0
                        , const int i1 = 0
                        , const int i2 = 0
                        , const int i3 = 0
                        , const int i4 = 0
                        , const int i5 = 0
                        , const int i6 = 0
                        , const int i7 = 0
                        , const int i8 = 0
                        , const int i9 = 0
                        ) const ;

    // Requires rank == 1 and std::is_integral<t0>::value and i{1-9} == 0
    template< typename t0 >
    reference operator()( const t0 & i0
                        , const int i1
                        , const int i2 = 0
                        , const int i3 = 0
                        , const int i4 = 0
                        , const int i5 = 0
                        , const int i6 = 0
                        , const int i7 = 0
                        , const int i8 = 0
                        , const int i9 = 0
                        ) const ;

    // improper member access operator follows pattern through at least rank nine.

    // Requires rank == 10 and std::is_integral<t{0-8}>::value and i9 == 0
    template< typename t0 , typename t1 , typename t2 , typename t3 , typename t4
            , typename t5 , typename t6 , typename t7 , typename t8 >
    reference operator()( const t0 & i0
                        , const t1 & i1
                        , const t2 & i2
                        , const t3 & i3
                        , const t4 & i4
                        , const t5 & i5
                        , const t6 & i6
                        , const t7 & i7
                        , const t8 & i8
                        , const int i9
                        ) const ;

    //--------------------
    // Construct/copy/destroy:

    ~view();
    constexpr view();
    constexpr view( const view & );
    constexpr view( view && );
    view & operator = ( const view & );
    view & operator = ( view && );

    constexpr view( pointer
                  , size_t implicit_N0 = 0
                  , size_t implicit_N1 = 0
                  , size_t implicit_N2 = 0
                  , size_t implicit_N3 = 0
                  , size_t implicit_N4 = 0
                  , size_t implicit_N5 = 0
                  , size_t implicit_N6 = 0
                  , size_t implicit_N7 = 0
                  , size_t implicit_N8 = 0
                  , size_t implicit_N9 = 0
                  );

    template< class UType , class ... UProperties >
    constexpr view( const view< UType , UProperties ... > & );

    template< class UType , class ... UProperties >
    view & operator = ( const view< UType , UProperties ... > & );
  };

  // Meta function to generate an array type with Rank implicit dimensions.
  // Example:  view< implicit_array_t<int,10> >

  template< typename T , unsigned Rank >
  struct implicit_array_type {
    using type = typename implict_array_type<T,Rank-1>::type [] ;
  };
  template< typename T >
  struct implicit_array_type<T,0> {
    using type = T ;
  };

  template< typename T , unsigned Rank >
  using implicit_array_t = typename implicit_array_type<T,Rank>::type ;

  // If necessary
  template< size_t , size_t , size_t , size_t , size_t
          , size_t , size_t , size_t , size_t , size_t >
  struct view_dimension ;

  }
  }

..

**using reference_type =**

  The type returned by the dereferencing operator is dependent upon
  the *DataType* and the *Properties*.
  For example, a potential property of *atomic* would cause the
  **reference_type** to be a proxy overloading operators for
  atomic access.

**using pointer_type =**

  The type input to a wrapping constructor.

**static constexpr unsigned rank =**

  The rank of the viewed array.

**constexpr size_t extent_#() const**
  
  Returns the exent of dimension # when ``# < rank()``
  and 1 when ( **rank** <= # < *rank upper bound* ).

**template< unsigned > constexpr size_t extent() const**

  Returns the exent of dimension # when ``# < rank()``
  and 1 when ( **rank** <= # < *rank upper bound* ).
  
**constexpr size_t size() const**

  Returns the product of the extents.

**using layout =**

  Is the layout type property that defaults to **void**.

**using is_regular = std::integral_constant<bool, ... >**

  Denoting by **is_regular::value** if the layout mapping is regular.

**constexpr size_t stride_#() const**

  For regular layout mapping returns the distance between members
  when index # is incremented by one.
  For not-regular layout mapping the return value is undefined.

**template< unsigned > constexpr size_t stride() const**

  For regular layout mapping returns the distance between members
  when index # is incremented by one.
  For not-regular layout mapping the return value is undefined.

**constexpr size_t span() const**

  For regular layout mapping returns
  one plus the maximum distance between any two members of the array.
  For not-regular layout mapping the return value is undefined.

**constexpr pointer data() const**

  For regular layout mapping returns
  pointer to member with the smallest address.
  For not-regular layout mapping the return value is undefined.

  Requires for regular layout mapping all members are in the
  range ``[ data() .. data() + span() )``.

**reference operator()() const**

  Returns a reference to the member of a rank zero array.

  Requires rank == 0.
  It is suggested that this requirement be enforced by conditionally
  defining the return type of the operator.

.. code-block:: c++

  typename std::conditional< rank() == 0 , reference
                           , error_tag_invalid_access_to_non_rank_zero_view >::type
  operator()() const

..

**reference operator()( /\* multi-index-argument-list \*/ ) const /\* proper \*/**

  Returns a reference to member associated with the *multi-index-argument-list*.

  Requires the rank of the mult-index-argument-list equal to the rank of the array
  and all multi-indices are an integral type.
  It is suggested that this requirement be enforced as follows.

.. code-block:: c++

  // proper rank 4 member access operator
  template< typename t0 , typename t1 , typename t2 , typename t3 , typename t4 >
  typename std::enable_if< rank() == 4 &&
                           std::is_integral<t0>::value &&
                           std::is_integral<t1>::value &&
                           std::is_integral<t2>::value &&
                           std::is_integral<t3>::value
                         , reference >::type
   operator()( const t0 & i0
             , const t1 & i1
             , const t2 & i2
             , const t3 & i3
             ) const ;

..

  Requires each index is within the extent of the corresponding dimension:
  ``0 <= i# < extent_#()``.
  It is suggested that this requirement be enforced when the **view** is
  given an array bounds checking checking property.

  [Discussion:
  Index arguments are accepted as constant references to
  templated types to defer type promotion of these arguments until 
  they appear in the layout mapping computation.
  This has been demonstrated to better enable conventional compilers to
  optimize code containting the layout mapping computation without the
  need for specialized pattern recognition of **view::operator()**.
  ]

**reference operator()( /\* multi-index-argument-list \*/ ) const /\* improper \*/**

  Returns a reference to the member associated with the *multi-index-argument-list*
  up to the rank of the array.

  Requires the rank of the multi-index-argument-list is greater than the rank of the array
  and all multi-indices are an integral type.

.. code-block:: c++

  // improper rank 4 member access operator
  template< typename t0 , typename t1 , typename t2 , typename t3 , typename t4 >
  typename std::enable_if< rank() == 4 &&
                           std::is_integral<t0>::value &&
                           std::is_integral<t1>::value &&
                           std::is_integral<t2>::value &&
                           std::is_integral<t3>::value
                         , reference >::type
   operator()( const t0 & i0
             , const t1 & i1
             , const t2 & i2
             , const t3 & i3
             , const int i4
             , const int i5 = 0
             , const int i6 = 0
             , const int i7 = 0
             , const int i8 = 0
             , const int i9 = 0
             ) const ;

..

  Requires each index is within the extent of the corresponding dimension:
  ``0 <= i# < extent_#()``.
  Note that when ``rank() <= i#`` then ``extent_#() == 1`` so if array bounds
  are enforces then these extraneous indices are required to be zero.
  It is suggested that this requirement be enforced when the **view** is
  given an array bounds checking checking property.

  [Discussion:
  In practice user codes often have conditional blocks depending upon
  the rank of the array.  If only the *proper* member access operators are defined
  then that operator will only exist for one of the conditional blocks.
  This is a significant usability deficiency.
  The *improper** member access operators support such user code by allowing the
  code to use a multi-index-argument-list with the maximal rank that the user code
  supports.
  ]
  
**constexpr view()**

  Effect: Construct a *null* view.

  Requires all implicit dimensions have an extent of zero.

  Requires ``data() == 0``.

**constexpr view( const view & rhs )**

  Effect: Construct a view of the array viewed by **rhs**.

  There may be other *property* dependent effects.

**view & operator = ( const view & rhs )**

  Effect: Assigns **this** to view the array viewed by **rhs**.

  There may be other *property* dependent effects.

**constexpr view( view && rhs )**

  Effect: Construct a view of the array viewed by **rhs** and then **rhs** is *null* view.

  There may be other *property* dependent effects.

**view & operator = ( view && rhs )**

  Effect: Assigns **this** to view the array viewed by **rhs** then assigns **rhs** to be a *null* view.

  There may be other *property* dependent effects.

**~view()**

  Effect: Assigns **this** to be a *null* view.

  There may be other *property* dependent effects.

**constexpr view( pointer ptr
                , size_t implicit_N0 = 0
                , size_t implicit_N1 = 0
                , size_t implicit_N2 = 0
                , size_t implicit_N3 = 0
                , size_t implicit_N4 = 0
                , size_t implicit_N5 = 0
                , size_t implicit_N6 = 0
                , size_t implicit_N7 = 0
                , size_t implicit_N8 = 0
                , size_t implicit_N9 = 0
                );**

  Effects:
  The *wrapping constructor** of a view with regular layout mapping
  constructs a multidimensional array view of the given member memory.

  Requires: Regular layout mapping.

  Requires: The input **ptr** references memory ``[ ptr .. ptr + span() )``.
  Note that the span requirement may be queried without constructing a view
  with the static **span** member function.

**template< class UType , class ... UProperties >
  constexpr view( const view< UType , UProperties ... > & rhs )**

  Effect: Constructs a view of the array viewed by **rhs**.

  Requires: This view type is assignable to the **rhs** view type.

  View compatibility includes compatibility of the value type, dimensions, and properties.

.. code-block:: c++

  view< int[][3] >      x(ptr,N0);
  view< const int[][] > y( x ); // OK: compatible const from non-const and implicit from explicit dimension
  view< int[][] >       z( y ); // Error: cannot assign non-const from const

..


**template< class UType , class ... UProperties >
  view & operator = ( const view< UType , UProperties ... > & rhs )**

  Effect: Assigns **this** to view the array viewed by **rhs**.

  Requires: This view type is assignable to the **rhs** view type.

--------------------------------------------------------------------
Assignable View
--------------------------------------------------------------------

It is essential that view of non-identical types be assignable.
For example:

.. code-block:: c++

  view< int[][3] > x( ptr , N0 );
  view< const int[][] > y( x ); // valid assignment

..

The 'std::is_assignable' meta-function will be partial specialized to
implement the view assignability rules regarding value type, dimensions, and properties.

.. code-block:: c++

template< class Utype , class ... Uprop , class Vtype , class ... Vprop >
struct is_assignable< view< Utype , Uprop ... > , view< Vtype , Vprop ... > >
  : public integral_const< bool ,
      is_assignable< typename view< Utype , Uprop ... >::pointer
                   , typename view< Vtype , Vprop ... >::pointer >::value
      &&
      ( view< Utype , Uprop ... >::rank() == view< Vtype , Vprop ... >::rank() )
      &&
      /* other conditions */
      > {}
    
.. /*


--------------------------------------------------------------------
View Property : Member Access Array Bounds Checking
--------------------------------------------------------------------

.. code-block:: c++

namespace std {
namespace experimental {
struct view_bounds_checking ;
}}

..

Array bounds checking is an invaluable tool for debugging user code.
Thus functionality traditionally requires global injection through
special compiler support.
In large, long running code global array bounds checking introduces
a signficant overhead that impedes the debugging process.
A member access array bounds checking view property allows
the selective injection of array bounds checking and removes
the need for special compiler support.

.. code-block:: c++

  // User enables array bounds checking for selected views.

  using x_property = typename std::conditional< ENABLE_ARRAY_BOUNDS_CHECKING , view_bounds_checking , void >::type ;

  view< int[][][3] , x_property > x(ptr,N0,N1);

..

Adding **view_bounds_checking** to the properties of a view has the
effect of introducing an array bounds check to each member access operation.
If the requirement ``0 <= i# < extent_#()`` fails **std::out_of_range** is thrown.


