///////////////////////////////////////////////////////////////////////////////
//  Copyright (c) 2015-2016 Bryce Adelstein Lelbach aka wash
//
//  Distributed under the Boost Software License, Version 1.0. (See accompanying
//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
////////////////////////////////////////////////////////////////////////////////

#if !defined(STD_CF36957A_A9C6_44BF_ABF1_7CD6BDEC6CF0)
#define STD_CF36957A_A9C6_44BF_ABF1_7CD6BDEC6CF0

#include "impl/fwd.hpp"
#include "impl/meta.hpp"
#include "impl/dimensions.hpp"

#include "impl/basic_layout_left.hpp"
#include "impl/layout_left.hpp"
#include "impl/accessor_native.hpp"

namespace std { namespace experimental 
{

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
struct array_ref
{
    // TYPES

    using dimensions = Dims;
    using layout = Layout;
    using accessor = Accessor;

    using size_type  = typename layout::size_type;
    using value_type = typename accessor::value_type;
    using pointer    = typename accessor::pointer;
    using reference  = typename accessor::reference;

    // CONSTRUCTORS, DESTRUCTORS AND ASSIGNMENT OPERATORS

    // Default constructor, yields the same result as from std::nullptr_t.
    // ENSURES: this->data() == nullptr && this->size() == 0
    constexpr array_ref() noexcept;

    // Construct from nullptr, results in a zero-length multi_array_ref.
    constexpr array_ref(std::nullptr_t) noexcept;

    // Constructs from a pointer + list of sizes, default constructs traits.
    // EXPECTS: ptr != nullptr 
    // EXPECTS: std::is_integral<> is true for all the types in Sizes
    // EXPECTS: num_dynamic_dims() == sizeof...(DynamicDim)
    // ENSURES: this->data() == p
    template <typename... Sizes>
    constexpr array_ref(pointer p, Sizes... sizes) noexcept;

    // Constructs from a pointer + dimensions<> + traits.
    // EXPECTS: ptr != nullptr 
    // ENSURES: this->data() == p
    constexpr array_ref(
        pointer p, dimensions const& d
      , layout const& l = Layout(), accessor const& a = Accessor()
        ) noexcept;

    // Conversion constructor.
    // TYPE-REQUIREMENTS: BValueType must be assignment-compatible
    template <typename OtherValueType>
    constexpr array_ref(
        array_ref<OtherValueType, Dims, Layout, Accessor> const& other
        ) noexcept;

    constexpr array_ref(array_ref const& b) noexcept = default;
    constexpr array_ref(array_ref&& b) noexcept = default;
    array_ref& operator=(array_ref const& b) noexcept = default;
    array_ref& operator=(array_ref&& b) noexcept = default;

    ~array_ref() = default;

    // METADATA ACCESS

    // Returns the number of dimensions of the referenced array.
    static constexpr size_type rank() noexcept;

    // Returns the number of dimension which are dynamic.
    static constexpr size_type num_dynamic_dims() noexcept;

    // ELEMENT ACCESS

    // Access the element at the specified multi-dimensional index.
    template <typename... Idx>
    typename std::enable_if<
        Dims::rank() == sizeof...(Idx)
        && detail::pack_is_integral<Idx...>::value
      , reference
    >::type operator()(Idx... idx) const noexcept;

    // Access the element at the specified raw index.
    template <typename Idx>
    typename std::enable_if<
        std::is_integral<Idx>::value
      , reference
    >::type operator[](Idx idx) const noexcept;

  private:
    pointer ptr_;
    Dims dims_;
    Layout layout_;
    Accessor accessor_;
};

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
constexpr
array_ref<ValueType, Dims, Layout, Accessor>::array_ref() noexcept
  : ptr_(nullptr)
  , dims_()
  , layout_()
  , accessor_()
{}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
constexpr
array_ref<ValueType, Dims, Layout, Accessor>::array_ref(
    std::nullptr_t
    ) noexcept
  : ptr_(nullptr)
  , dims_()
  , layout_()
  , accessor_()
{}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
template <typename... Sizes>
constexpr
array_ref<ValueType, Dims, Layout, Accessor>::array_ref(
    pointer p, Sizes... sizes
    ) noexcept
  : ptr_(p)
  , dims_(sizes...) // dimensions<> does the relevant static_asserts.
  , layout_()
  , accessor_()
{}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
constexpr
array_ref<ValueType, Dims, Layout, Accessor>::array_ref(
    pointer p, dimensions const& d, layout const& l, accessor const& a
    ) noexcept
  : ptr_(p)
  , dims_(d)
  , layout_(l)
  , accessor_(a)
{}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
template <typename OtherValueType> 
constexpr
array_ref<ValueType, Dims, Layout, Accessor>::array_ref(
    array_ref<OtherValueType, Dims, Layout, Accessor> const& other
    ) noexcept
  : ptr_(other.ptr_)
  , dims_(other.dims_)
  , layout_(other.layout_)
  , accessor_(other.accessor_)
{}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
inline static constexpr typename
    array_ref<ValueType, Dims, Layout, Accessor>::size_type
rank() noexcept
{
    return Dims::rank();
}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
inline static constexpr typename
    array_ref<ValueType, Dims, Layout, Accessor>::size_type
num_dynamic_dims() noexcept
{
    return Dims::num_dynamic_dims();
}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
template <typename... Idx>
inline typename std::enable_if<
    Dims::rank() == sizeof...(Idx) && detail::pack_is_integral<Idx...>::value
  , typename array_ref<ValueType, Dims, Layout, Accessor>::reference
>::type array_ref<ValueType, Dims, Layout, Accessor>::operator()(
    Idx... idx
    ) const noexcept
{
    size_type const raw_idx = layout_.index(dims_, idx...);
    return accessor_.access(ptr_, raw_idx);
}

template <typename ValueType, typename Dims, typename Layout, typename Accessor>
template <typename Idx>
inline typename std::enable_if<
    std::is_integral<Idx>::value
  , typename array_ref<ValueType, Dims, Layout, Accessor>::reference
>::type array_ref<ValueType, Dims, Layout, Accessor>::operator[](
    Idx idx
    ) const noexcept
{
    return accessor_.access(ptr_, idx);
}

}} // std::experimental

#endif // STD_CF36957A_A9C6_44BF_ABF1_7CD6BDEC6CF0

