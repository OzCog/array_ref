/*
//@HEADER
// ************************************************************************
// 
//                        Kokkos v. 2.0
//              Copyright (2014) Sandia Corporation
// 
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact  H. Carter Edwards (hcedwar@sandia.gov)
// 
// ************************************************************************
//@HEADER
*/

#ifndef STD_EXPERIMENTAL_ARRAY_REF_HEADER
#define STD_EXPERIMENTAL_ARRAY_REF_HEADER

#include <initializer_list>
#include <iterator>
#include <algorithm>
#include <detail/dimension_helper>
#include <detail/array_helper>

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------

namespace std {
namespace experimental {
namespace array_property {

template< typename ValueType , ValueType ... Dim >
struct dimension_typed ;

template< size_t ... Dim >
using dimension = dimension_typed< size_t , Dim ... > ;


template< typename ValueType , ValueType ... Dim >
struct dimension_typed : detail::dimension_extent< 0 , ValueType , Dim... >
{
private:

  enum : unsigned { Rank = sizeof...(Dim) };

  using base = detail::dimension_extent< 0 , ValueType , Dim... > ;

  template< unsigned J >
  constexpr bool check_bounds() const noexcept { return true ; }

  template< unsigned J , typename T , typename ... IntegralType >
  constexpr bool check_bounds( T i , IntegralType ... tail ) const noexcept
    {
      return 0 <= i && i < base::template extent<J>::value &&
      dimension_typed::template check_bounds<J+1>( tail ... );
    }

  template< unsigned I >
  constexpr typename std::enable_if< !( I < Rank ), ValueType >::type
  get_extent( unsigned ) const noexcept
    { return 1 ; }

  template< unsigned I >
  constexpr typename std::enable_if<( I < Rank ), ValueType >::type
  get_extent( unsigned i ) const noexcept
    {
      return I == i ? base::template extent<I>::value
                    : dimension_typed::template get_extent<I+1>(i) ;
    }

  template< unsigned I >
  constexpr typename std::enable_if< !( I < Rank ), ValueType >::type
  get_size() const noexcept
    { return 1 ; }

  template< unsigned I >
  constexpr typename std::enable_if<( I < Rank ), ValueType >::type
  get_size() const noexcept
    {
      return base::template extent<I>::value *
             dimension_typed::template get_size<I+1>() ;
    }

public:

  //----------------------------------------
  // TYPES

  using value_type = ValueType ; ///< storage type for extent values
  using size_type  = unsigned ;  ///< extent indexing type

  //----------------------------------------
  // OBSERVERS

  /**\brief  Number extents */
  static constexpr size_type rank() noexcept { return Rank ; }

  /**\brief  Number of dynamic extents */
  static constexpr size_type rank_dynamic() noexcept { return base::rank_dynamic ; }

  /**\brief Product of extents */
  constexpr value_type size() const noexcept
    { return dimension_typed::get_size<0>(); }

  /**\brief  Value of an extent */
  constexpr value_type extent( const size_type i ) const noexcept
    { return dimension_typed::template get_extent<0>(i); }

  /**\brief  Value of an extent */
  template< size_type I >
  constexpr value_type extent() const noexcept
    { return base::template extent<I>::value ; }

  /**\brief  Value of a the static extent */
  template< size_type I >
  static constexpr value_type static_extent() noexcept
    { return base::template extent<I>::value_static ; }

  //----------------------------------------

  constexpr dimension_typed() = default ;
  constexpr dimension_typed( dimension_typed && ) = default ;
  constexpr dimension_typed( dimension_typed const & ) = default ;
  dimension_typed & operator = ( dimension_typed const & ) = default ;

  template< value_type ... T >
  explicit dimension_typed( dimension_typed<value_type,T...> const & D ) noexcept
    : base( D )
    { static_assert( D.rank() == rank() , "" ); }

  template< typename ... IntegralType >
  constexpr explicit dimension_typed( IntegralType ... dyn_dims ) noexcept
    : base( dyn_dims... )
    {
      static_assert( detail::pack_is_integral<IntegralType...>::value , "" );
      static_assert( rank_dynamic() == sizeof...(IntegralType) , "" );
    }

  template< typename IntegralType >
  constexpr explicit dimension_typed( IntegralType const * const dyn_dims ) noexcept
    : base( dyn_dims )
    {
      static_assert( std::is_integral<IntegralType>::value , "" );
    }

  template< typename ... IntegralType >
  constexpr bool in_bounds( IntegralType ... indices ) const noexcept
    { return check_bounds<0>( indices... ); }
};

}}} // std::experimental::array_property

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------

namespace std {
namespace experimental {
namespace array_property {

struct layout_right {

template< typename Dimension >
struct mapping : public Dimension {
public:

  // TYPES

  using size_type  = typename Dimension::size_type ;
  using value_type = typename Dimension::value_type ;

private:

  template< unsigned I , typename iType >
  void get_stride( iType * const s ) const noexcept
    {
      if ( I + 1 < Dimension::rank() ) {
        mapping::template get_stride<(I+1<Dimension::rank()?I+1:I)>(s);
        s[I] = s[I+1] * Dimension::template extent<I>::value ;
      }
      else {
        s[I] = 1 ;
      }
    }

  template< unsigned I >
  constexpr value_type get_stride( size_type i ) const noexcept
    {
      // Start the product when i < I
      // Multiply to the right until the end.

      return ( i < I ? Dimension::template extent<I>::value : 1 ) *
             ( I + 1 < Dimension::rank()
               ? mapping::template get_stride<(I+1<Dimension::rank()?I+1:I)>(i)
               : 1 );
    }

  template< unsigned I >
  constexpr value_type offset( value_type sum ) const noexcept
    { return sum ; }

  template< unsigned I , typename IR , typename ... Arg >
  constexpr value_type
  offset( value_type sum , IR ir , Arg ... arg ) const noexcept
    {
      // Guard extent extraneous zeros in the tail.
      return I ? mapping::template offset<(I?I-1:0)>( ir + Dimension::template extent< Dimension::rank() - I >::value * sum , arg... ) : sum ;
    }

public:

  // OBSERVERS

  static constexpr bool is_always_unique = true ;
  static constexpr bool is_always_regular = true ;
  static constexpr bool is_always_contiguous = true ;

  constexpr bool is_unique() const noexcept
    { return is_always_unique ; }

  constexpr bool is_regular() const noexcept
    { return is_always_regular ; }

  constexpr bool is_contiguous() const noexcept
    { return is_always_contiguous ; }

  constexpr value_type span() const noexcept
    { return Dimension::size(); }

  constexpr value_type stride( size_type i ) const noexcept
    { return mapping::template get_stride<0>(i); }

  template< typename iType >
  void stride( iType * const s ) const noexcept
    { mapping::template get_stride<0>(s); }

  // CTOR

  constexpr mapping() noexcept = default ;

  constexpr explicit mapping( Dimension const & D ) noexcept : Dimension(D) {}

  // OPERATOR

  template< typename ... Integral >
  constexpr typename std::enable_if
    < array_property::detail::pack_is_integral< Integral ... >::value &&
      Dimension::rank() == 0
    , typename Dimension::value_type 
    >::type operator()
    ( Integral const & ... indices ) const noexcept
    { return 0 ; } 

  template< typename I0 , typename ... Integral >
  constexpr typename std::enable_if
    < array_property::detail::pack_is_integral< I0 , Integral ... >::value &&
      0 < Dimension::rank()
    , typename Dimension::value_type 
    >::type operator()
    ( I0 const & i0 , Integral const & ... indices ) const noexcept
    { return mapping::template offset< Dimension::rank() - 1 >(i0,indices...); }
};

};

struct layout_left {

template< typename Dimension >
struct mapping : public Dimension {
public:

  // TYPES

  using size_type  = typename Dimension::size_type ;
  using value_type = typename Dimension::value_type ;

private:

  template< unsigned I , typename iType >
  void get_stride( iType * const s ) const noexcept
    {
      if ( I < Dimension::rank() ) {
        s[I] = I ? s[I-1] * Dimension::template extent<I?I-1:I>::value : 1 ;
        mapping::template get_stride<(I+1<Dimension::rank()?I+1:I)>(s);
      }
    }

  template< unsigned I >
  constexpr value_type get_stride( size_type const i ) const noexcept
    {
      return ( I < i ? Dimension::template extent<I>::value *
                       mapping::template get_stride<(I+1<Dimension::rank()?I+1:I)>(i)
                     : 1 );
    }

  template< unsigned I >
  constexpr value_type offset() const noexcept
    { return 0 ; }

  template< unsigned I , typename IR , typename ... Arg >
  constexpr value_type
  offset( IR ir , Arg ... arg ) const noexcept
    {
      return ir + Dimension::template extent<I>::value *
                  mapping::template offset<I+1>( arg... );
    }

public:

  // OBSERVERS

  static constexpr bool is_always_unique = true ;
  static constexpr bool is_always_regular = true ;
  static constexpr bool is_always_contiguous = true ;

  constexpr bool is_unique() const noexcept
    { return is_always_unique ; }

  constexpr bool is_regular() const noexcept
    { return is_always_regular ; }

  constexpr bool is_contiguous() const noexcept
    { return is_always_contiguous ; }

  constexpr value_type span() const noexcept
    { return Dimension::size(); }

  constexpr value_type stride( size_type i ) const noexcept
    { return mapping::template get_stride<0>(i); }

  template< typename iType >
  void stride( iType * const s ) const noexcept
    { mapping::template get_stride<0>(s); }

  // CTOR

  constexpr mapping() noexcept = default ;

  constexpr explicit mapping( Dimension const & D ) noexcept : Dimension(D) {}

  // OPERATOR

  template< typename ... Integral >
  constexpr typename std::enable_if
    < array_property::detail::pack_is_integral< Integral ... >::value &&
      0 < Dimension::rank()
    , typename Dimension::value_type 
    >::type operator()
    ( Integral const & ... indices ) const noexcept
    { return mapping::template offset<0>(indices...); }
};

};

//--------------------------------------------------------------------------

struct layout_stride {

template< typename Dimension >
struct mapping : public Dimension {
public:

  // TYPES

  using size_type  = typename Dimension::size_type ;
  using value_type = typename Dimension::value_type ;

private:

  value_type m_stride[ Dimension::rank() ];
  int        m_unique ;
  int        m_contig ;

  template< unsigned I >
  constexpr value_type get_stride( size_type const i ) const noexcept
    {
      return ( I < i ? Dimension::template extent<I>::value *
                       mapping::template get_stride<(I+1<Dimension::rank()?I+1:I)>(i)
                     : 1 );
    }

  template< unsigned I >
  constexpr value_type offset() const noexcept
    { return 0 ; }

  template< unsigned I , typename IR , typename ... Arg >
  constexpr value_type
  offset( IR ir , Arg ... arg ) const noexcept
    {
      return ir * m_stride[I] + mapping::template offset<I+1>( arg... );
    }

public:

  // OBSERVERS

  static constexpr bool is_always_unique = false ;
  static constexpr bool is_always_regular = true ;
  static constexpr bool is_always_contiguous = false ;

  // Only unique if { dimension , stride } pairs
  // do not overlap
  constexpr bool is_unique() const noexcept { return m_unique ; }

  constexpr bool is_regular() const noexcept
    { return is_always_regular ; }

  constexpr bool is_contiguous() const noexcept { return m_contig ; }

  constexpr value_type span() const noexcept
    { return Dimension::size(); }

  constexpr value_type stride( size_type i ) const noexcept
    { return mapping::template get_stride<0>(i); }

  template< typename iType >
  void stride( iType * const s ) const noexcept
    {
      for ( size_type i = 0 ; i < Dimension::rank() ; ++i ) {
        s[i] = m_stride[i] ;
      }
    }

  // CTOR

  constexpr mapping() noexcept
    : Dimension()
    , m_stride{0}
    , m_unique{0}
    , m_contig{0}
    {}

  template< typename D >
  explicit mapping( layout_left::template mapping<D> const & M ) noexcept
    : Dimension( static_cast<D const &>(M) )
    , m_stride{0}
    , m_unique{1}
    , m_contig{1}
    { M.stride( m_stride ); }

  template< typename D >
  explicit mapping( layout_right::template mapping<D> const & M ) noexcept
    : Dimension( static_cast<D const &>(M) )
    , m_stride{0}
    , m_unique{1}
    , m_contig{1}
    { M.stride( m_stride ); }

  template < typename IntType >
  explicit mapping( IntType const * const E
                  , IntType const * const S ) noexcept
    : Dimension(E)
    , m_stride{0}
    , m_unique{0}
    , m_contig{0}
    {
      std::pair<value_type,value_type> tmp[ Dimension::rank() ];

      for ( size_type i = 0 ; i < Dimension::rank() ; ++i ) {
        m_stride[i] = S[i] ;
        tmp[i].first = S[i];
        tmp[i].second = E[i];
      }

      std::sort( tmp , tmp + Dimension::rank() );

      m_unique = 1 ;
      m_contig = 1 ;
      for ( size_type i = 1 ; i < Dimension::rank() ; ++i ) {
        const value_type prev = tmp[i-1].first * tmp[i-1].second ;
        if ( tmp[i].first != prev ) { m_contig = 0 ; }
        if ( tmp[i].first <  prev ) { m_unique = 0 ; }
      }
    }

  // OPERATOR

  template< typename ... Integral >
  constexpr typename std::enable_if
    < array_property::detail::pack_is_integral< Integral ... >::value &&
      0 < Dimension::rank()
    , typename Dimension::value_type 
    >::type operator()
    ( Integral const & ... indices ) const noexcept
    { return mapping::template offset<0>(indices...); }
};

};

//--------------------------------------------------------------------------

struct all_type {};

constexpr all_type all ;

}}} // std::experimental::array_property

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------

namespace std {
namespace experimental {

//--------------------------------------------------------------------------

template < typename DataType , typename ... Properties >
struct array_ref
{
private:

  template< typename , typename ... > friend struct array_ref ;

  using unpack = array_property::detail::unpack_array_properties< DataType , Properties... > ;

  using bounds_check = typename unpack::bounds_check ;

public:

  // TYPES

  using layout     = typename unpack::layout ;
  using dimension  = typename unpack::dimension ;
  using mapping    = typename unpack::layout::template mapping< dimension > ;
  using size_type  = typename dimension::value_type ;
  using value_type = typename unpack::value_type ;

  using reference  = value_type & ;
  using pointer    = value_type * ;
  using iterator   = value_type * ;
  using const_iterator = typename std::add_const<value_type>::type * ;
  using reverse_iterator = std::reverse_iterator< iterator > ;
  using const_reverse_iterator = std::reverse_iterator< const_iterator > ;

  // CONSTRUCTORS AND ASSIGNMENT OPERATORS

  constexpr array_ref() noexcept : m_ptr(0), m_map() {}
  constexpr array_ref(array_ref const& b) noexcept = default;
  constexpr array_ref(array_ref&& b) noexcept = default;
  array_ref& operator=(array_ref const& b) noexcept = default;
  array_ref& operator=(array_ref&& b) noexcept = default;

  template< typename D , typename ... P >
  constexpr array_ref( array_ref<D,P...> const & rhs ) noexcept
    : m_ptr( rhs.m_ptr )
    , m_map( rhs.m_map )
    {}

  template< typename D , typename ... P >
  array_ref & operator = ( array_ref<D,P...> const & rhs ) noexcept
    {
      m_ptr = rhs.m_ptr ;
      m_map = rhs.m_map ;
      return *this ;
    }

  template < typename... UnsignedIntegers >
  explicit constexpr array_ref
    ( typename std::enable_if
        < array_property::detail::pack_is_integral< UnsignedIntegers... >::value
        , pointer
        >::type p
    , UnsignedIntegers ... dynamic_dims
    ) noexcept
    : m_ptr(p), m_map( dimension(dynamic_dims...) ) {}

  explicit constexpr array_ref( pointer p, mapping const& m ) noexcept
    : m_ptr(p), m_map(m) {}

  // Observers for domain dimension

  static constexpr size_type rank() noexcept
    { return dimension::rank(); }

  static constexpr size_type rank_dynamic() noexcept
    { return dimension::rank_dynamic(); }

  constexpr size_type size() const noexcept
    { return m_map.size(); }

  constexpr size_type extent( size_type coord ) const noexcept
    { return m_map.extent( coord ); }

  // Observers for mapping

  static constexpr bool is_always_unique = mapping::is_always_unique ;
  static constexpr bool is_always_regular = mapping::is_always_regular ;
  static constexpr bool is_always_contiguous = mapping::is_always_contiguous ;

  constexpr bool is_unique() const noexcept  { return m_map.is_unique(); }
  constexpr bool is_regular() const noexcept { return m_map.is_regular(); }
  constexpr bool is_contiguous() const noexcept {return m_map.is_contiguous();}

  constexpr value_type span() const noexcept
    { return m_map.span(); }

  constexpr value_type stride( size_type i ) const noexcept
    { return m_map.stride(i); }

  // ELEMENT AND DATA ACCESS 

  constexpr pointer data() const noexcept { return m_ptr ; }

  template <typename... UnsignedIntegers>
  typename std::enable_if
    <( dimension::rank() <= sizeof...(UnsignedIntegers) &&
       array_property::detail::pack_is_integral<UnsignedIntegers...>::value )
    , reference
    >::type
  operator()(UnsignedIntegers... indices) const noexcept
    { return m_ptr[ m_map( indices... ) ]; }

  template < typename IntType >
  typename std::enable_if
    <( dimension::rank() == 1 && std::is_integral<IntType>::value )
    , reference
    >::type
  operator[]( IntType idx ) const noexcept
    { return m_ptr[ m_map( idx ) ]; }

  constexpr iterator begin() const noexcept { return m_ptr ; }
  constexpr iterator end() const noexcept { return m_ptr + span(); }
  constexpr const_iterator cbegin() const noexcept { return m_ptr ; }
  constexpr const_iterator cend() const noexcept { return m_ptr + span(); }

  constexpr reverse_iterator rbegin() const noexcept
    { return reverse_iterator( m_ptr + span() ); }

  constexpr reverse_iterator rend() const noexcept
    { return reverse_iterator( m_ptr ); }

  constexpr const_reverse_iterator crbegin() const noexcept
    { return const_reverse_iterator( m_ptr + span() ); }

  constexpr const_reverse_iterator crend() const noexcept
    { return const_reverse_iterator( m_ptr ); }

private:
  pointer  m_ptr ;
  mapping  m_map ;
};

//--------------------------------------------------------------------------

template< typename DataType , typename ... Properties
        , typename ... SliceSpecs >
typename array_property::detail
  ::subarray_generator< array_ref< DataType , Properties ... > , SliceSpecs ... >
    ::type
subarray( array_ref< DataType , Properties... > const & a
        , SliceSpecs ... slice_specs
        )
{
  using ArrayRefType = array_ref< DataType , Properties ... > ;
  using generator = array_property::detail::subarray_generator< ArrayRefType , SliceSpecs ... > ;
  using layout = typename generator::type::layout ;

  static_assert( ArrayRefType::rank() == sizeof...(SliceSpecs) , "" );

  return generator::template apply< layout >( a , slice_specs ... );
}


}} // std::experimental

#endif // #ifndef STD_EXPERIMENTAL_ARRAY_REF_HEADER

